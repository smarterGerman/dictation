<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>German Dictation Tool</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fdfdfd;
            color: #1f2937;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            background: transparent;
        }

        .content { 
            padding: 0; 
            width: 100%; 
        }

        /* ----- AUDIO SECTION ---------------------------------------------- */
        .audio-section {
            padding: 28px 20px;
            margin-bottom: 24px;
            background: linear-gradient(135deg, #e0f2fe 0%, #f3e5f5 100%);
            border-radius: 20px;
            border: none;
            text-align: center;
            color: #374151;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            width: 100%;
        }
        
        .sentence-info { 
            margin-bottom: 24px; 
            font-size: 15px; 
            color: #6b7280; 
            font-weight: 500; 
        }

        .audio-controls { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            gap: 12px; 
            margin-bottom: 28px; 
            flex-wrap: nowrap; 
        }

        .nav-btn,
        .play-btn { 
            border: none; 
            border-radius: 50%; 
            cursor: pointer; 
            transition: all .3s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }

        .nav-btn {
            width: 52px; 
            height: 52px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            font-size: 18px;
            color: #6b7280;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        .nav-btn:hover:not(:disabled) { 
            transform: translateY(-2px); 
            background: rgba(255, 255, 255, 1);
            color: #374151;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }
        
        .nav-btn:disabled { 
            opacity:0.3; 
            cursor:not-allowed; 
        }

        .play-btn {
            position: relative;
            width: 72px; 
            height: 72px;
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.3);
            font-size: 28px;
            color: white;
        }
        
        .play-btn:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 12px 32px rgba(168, 85, 247, 0.4);
        }
        
        .play-btn:disabled{
            opacity:.5;
            cursor:not-allowed;
        }
        
        .play-btn::before { 
            content:''; 
            position:absolute; 
            left:50%; 
            top:50%; 
            transform:translate(-50%,-50%); 
        }
        
        .play-btn.playing::before { 
            width:4px;
            height:20px;
            background:white;
            box-shadow:8px 0 0 white; 
        }
        
        .play-btn:not(.playing)::before { 
            border-left:12px solid white; 
            border-top:8px solid transparent; 
            border-bottom:8px solid transparent; 
        }

        #timeDisplay { 
            min-width:110px; 
            font-size:16px; 
            color:#6b7280; 
            font-weight:500; 
            margin-left: 16px; 
        }
        
        .progress-container { 
            width:320px; 
            height:8px; 
            background:rgba(255, 255, 255, 0.4); 
            border-radius:20px; 
            overflow:hidden; 
            margin:0 auto; 
        }
        
        .progress-bar { 
            height:100%; 
            width:0%; 
            background:linear-gradient(90deg, #a855f7, #ec4899); 
            border-radius:20px; 
            transition:width .3s ease; 
        }

        /* ----- INPUT / FEEDBACK ------------------------------------------- */
        .input-area { 
            display:flex; 
            flex-direction:column; 
            gap:20px; 
            padding: 0; 
        }
        
        .input-field {
            width:100%; 
            min-height:100px; 
            padding:18px;
            background: linear-gradient(135deg, #fef7ff 0%, #f0f9ff 100%); 
            color:#374151;
            border:2px solid #e879f9; 
            border-radius: 16px;
            font-size:16px; 
            line-height:1.5; 
            resize:vertical;
            transition:all .3s ease;
            box-shadow: 0 4px 16px rgba(232, 121, 249, 0.1);
        }
        
        .input-field:focus { 
            border-color:#c084fc; 
            box-shadow:0 0 0 4px rgba(192, 132, 252, 0.15), 0 4px 16px rgba(232, 121, 249, 0.2); 
            outline:none; 
            transform: translateY(-1px);
        }
        
        .live-feedback {
            min-height:100px; 
            padding:18px;
            background: linear-gradient(135deg, #ecfdf5 0%, #fef3ff 100%); 
            border:2px solid #a78bfa; 
            border-radius: 16px;
            font-size:16px; 
            line-height:1.5; 
            white-space:pre-wrap; 
            word-break:break-word;
            color: #9ca3af;
            box-shadow: 0 4px 16px rgba(167, 139, 250, 0.1);
        }

        /* feedback colors */
        .char-correct{color:#059669;font-weight:500;} 
        .char-wrong-position{color:#d97706;font-weight:500;} 
        .char-wrong{color:#dc2626;text-decoration:underline;font-weight:500;} 
        .char-missing{color:#d97706;font-style:italic;font-weight:500;} 
        .char-extra{color:#2563eb;font-weight:500;} 
        .char-word-boundary,.char-char-space{color:#9ca3af;}

        /* ----- OPTIONS ----------------------------------------------------- */
        .options { 
            display:flex; 
            gap:20px; 
            margin:24px 0; 
            flex-wrap:wrap; 
        }
        
        .toggle{
            display:flex;
            align-items:center;
            gap:12px;
            cursor:pointer;
            color:#6b7280;
            font-weight:500;
        }
        
        .toggle input{
            width:20px;
            height:20px;
            accent-color:#e879f9;
            cursor:pointer;
        }

        /* ----- STATS & CONTROLS ------------------------------------------- */
        .stats-section{
            margin:32px 0 0 0;
            padding-top:24px;
            border-top:1px solid #f3f4f6;
        }
        
        .stats{
            display:grid;
            grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
            gap:16px;
            margin-bottom:24px;
        }
        
        .stat-item{
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border:none;
            border-radius:16px;
            padding:24px;
            text-align:center;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: all .3s ease;
        }
        
        .stat-item:hover{
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        }
        
        .stat-value{
            font-size:36px;
            font-weight:700;
            color:#e879f9;
            margin-bottom:8px;
            display:block;
        }
        
        .stat-label{
            font-size:14px;
            font-weight:500;
            color:#6b7280;
        }

        .controls{
            display:flex;
            justify-content:center;
            gap:12px;
            flex-wrap:wrap;
        }
        
        .control-btn{
            padding:14px 28px;
            border-radius:25px;
            border:none;
            background: linear-gradient(135deg, #e879f9 0%, #c084fc 100%);
            color: white;
            font-size:15px;
            font-weight:600;
            cursor:pointer;
            transition:all .3s ease;
            box-shadow: 0 4px 16px rgba(232, 121, 249, 0.3);
        }
        
        .control-btn:hover{
            background: linear-gradient(135deg, #d946ef 0%, #a855f7 100%);
            transform:translateY(-2px);
            box-shadow: 0 8px 24px rgba(232, 121, 249, 0.4);
        }
        
        .control-btn:active{
            transform:translateY(-1px);
        }

        .reference-text{
            margin-top:24px;
            padding:20px;
            background:#fef9e7;
            border:1px solid #fcd34d;
            border-radius:8px;
            color:#92400e;
            display:none;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        /* ----- RESPONSIVE -------------------------------------------------- */
        @media(max-width:768px){
            body { padding: 10px; }
            .audio-section{ padding: 20px 15px; }
            .input-field, .live-feedback{ padding: 15px; font-size: 15px; }
            .audio-controls{ gap: 8px; }
            .nav-btn{ width: 44px; height: 44px; font-size: 16px; }
            .play-btn{ width: 64px; height: 64px; font-size: 24px; }
            .controls{ flex-direction: column; }
            .control-btn{ width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <!-- AUDIO SECTION -->
            <div class="audio-section">
                <div id="lessonInfo" style="margin-bottom:10px;font-size:14px;color:#6b7280;text-align:center;">Loading lesson...</div>
                <div class="sentence-info" id="sentenceInfo">Sentence 1 of 1</div>
                <div class="audio-controls">
                    <button class="nav-btn" id="prevBtn" title="Previous sentence">‹</button>
                    <button class="play-btn" id="playBtn"></button>
                    <button class="nav-btn" id="nextBtn" title="Next sentence">›</button>
                    <span id="timeDisplay">0:00 / 0:00</span>
                </div>
                <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                <audio id="audioPlayer" preload="metadata"></audio>
            </div>

            <!-- TEXT & FEEDBACK -->
            <div class="text-section">
                <div class="input-area">
                    <textarea class="input-field" id="userInput" placeholder="Type what you hear here... (Use ae for ä, oe for ö, ue for ü, B for ß)"></textarea>
                    <div class="live-feedback" id="liveFeedback">Live Feedback</div>
                </div>

                <div class="options">
                    <label class="toggle"><input type="checkbox" id="ignoreCaseToggle" checked> Ignore Capitalization</label>
                </div>

                <div class="reference-text" id="referenceText"></div>
            </div>

            <!-- STATS & CONTROLS -->
            <div class="stats-section">
                <div class="stats" id="statsSection" style="display:none;">
                    <div class="stat-item"><span class="stat-label">Accuracy</span><span class="stat-value" id="accuracyPercent">0%</span></div>
                    <div class="stat-item"><span class="stat-label">Correct Words</span><span class="stat-value" id="correctWords">0</span></div>
                    <div class="stat-item"><span class="stat-label">Wrong Words</span><span class="stat-value" id="wrongWords">0</span></div>
                    <div class="stat-item"><span class="stat-label">Time Taken</span><span class="stat-value" id="timeTaken">0:00</span></div>
                </div>
                <div class="controls">
                    <button class="control-btn" id="checkBtn">Check Result</button>
                    <button class="control-btn" id="resetBtn">Reset</button>
                    <button class="control-btn" id="revealBtn">Show Answer</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Auto-resize iframe height for Teachable integration
        function sendHeightToParent() {
            const height = document.body.scrollHeight;
            if (window.parent !== window) {
                window.parent.postMessage({ frameHeight: height }, '*');
            }
        }

        // Call on load and when content changes
        window.addEventListener('load', sendHeightToParent);
        window.addEventListener('resize', sendHeightToParent);

        // App state
        let referenceText = '';
        let isPlaying = false;
        let vttCues = [];
        let currentCueIndex = 0;
        let hasStartedTyping = false;
        
        // Timer tracking
        let sentenceStartTime = null;
        let totalSessionTime = 0;
        
        // Stats tracking
        let sessionResults = [];

        // Configuration
        const CONFIG = {
            audioBaseUrl: 'https://raw.githubusercontent.com/smarterGerman/german-dictation-lessons/main/audio'
        };

        // DOM elements
        let audioPlayer, playBtn, progressBar, timeDisplay, referenceTextDiv, lessonInfo, statsSection;
        let userInput, liveFeedback, accuracyPercent, correctWords, wrongWords;
        let checkBtn, resetBtn, revealBtn, ignoreCaseToggle;
        let prevBtn, nextBtn, sentenceInfo;

        // Initialize when page loads
        window.addEventListener('load', function() {
            // Get DOM elements
            audioPlayer = document.getElementById('audioPlayer');
            playBtn = document.getElementById('playBtn');
            progressBar = document.getElementById('progressBar');
            timeDisplay = document.getElementById('timeDisplay');
            referenceTextDiv = document.getElementById('referenceText');
            lessonInfo = document.getElementById('lessonInfo');
            statsSection = document.getElementById('statsSection');
            userInput = document.getElementById('userInput');
            liveFeedback = document.getElementById('liveFeedback');
            accuracyPercent = document.getElementById('accuracyPercent');
            correctWords = document.getElementById('correctWords');
            wrongWords = document.getElementById('wrongWords');
            checkBtn = document.getElementById('checkBtn');
            resetBtn = document.getElementById('resetBtn');
            revealBtn = document.getElementById('revealBtn');
            ignoreCaseToggle = document.getElementById('ignoreCaseToggle');
            prevBtn = document.getElementById('prevBtn');
            nextBtn = document.getElementById('nextBtn');
            sentenceInfo = document.getElementById('sentenceInfo');

            // Set up event listeners
            if (playBtn) playBtn.addEventListener('click', togglePlayback);
            if (prevBtn) prevBtn.addEventListener('click', goToPreviousSentence);
            if (nextBtn) nextBtn.addEventListener('click', goToNextSentence);
            if (userInput) {
                userInput.addEventListener('input', handleUserInput);
                userInput.addEventListener('keydown', handleKeyDown);
            }
            if (checkBtn) checkBtn.addEventListener('click', showFinalResult);
            if (resetBtn) resetBtn.addEventListener('click', resetDictation);
            if (revealBtn) revealBtn.addEventListener('click', showAnswer);
            if (ignoreCaseToggle) ignoreCaseToggle.addEventListener('change', updateLiveFeedback);

            if (audioPlayer) {
                audioPlayer.addEventListener('play', () => {
                    isPlaying = true;
                    if (playBtn) {
                        playBtn.classList.add('playing');
                        playBtn.textContent = '';
                    }
                });
                audioPlayer.addEventListener('pause', () => {
                    isPlaying = false;
                    if (playBtn) {
                        playBtn.classList.remove('playing');
                        playBtn.textContent = '';
                    }
                });
                audioPlayer.addEventListener('timeupdate', handleTimeUpdate);
            }

            // Load first lesson
            const lessonId = getLessonIdFromUrl() || 1;
            loadLesson(lessonId);

            // Send height after content loads
            setTimeout(sendHeightToParent, 500);
        });

        // Handle user input with German character conversion and live feedback
        function handleUserInput(e) {
            // Start timer on first keystroke for current sentence
            if (!hasStartedTyping && e.target.value.trim().length > 0) {
                hasStartedTyping = true;
                sentenceStartTime = Date.now();
                console.log('Timer started for sentence', currentCueIndex + 1);
            }
            
            const cursorPos = e.target.selectionStart;
            const convertedText = convertGermanChars(e.target.value);
            if (convertedText !== e.target.value) {
                e.target.value = convertedText;
                e.target.setSelectionRange(cursorPos, cursorPos);
            }
            updateLiveFeedback();
            
            // Update height when content changes
            setTimeout(sendHeightToParent, 100);
        }

        // Handle keyboard shortcuts
        function handleKeyDown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                processCurrentSentenceAndAdvance();
            }
        }

        // Process current sentence stats and move to next
        function processCurrentSentenceAndAdvance() {
            if (!userInput.value.trim()) {
                playCurrentSentence();
                return;
            }

            // Calculate sentence time
            let sentenceTime = 0;
            if (hasStartedTyping && sentenceStartTime) {
                sentenceTime = (Date.now() - sentenceStartTime) / 1000;
                totalSessionTime += sentenceTime;
                console.log(`Sentence ${currentCueIndex + 1} completed in ${sentenceTime.toFixed(1)}s`);
            }

            // Calculate and store stats for current sentence
            const userText = userInput.value;
            const comparison = compareTexts(referenceText, userText);
            const wordStats = calculateWordStats(comparison);
            
            // Store complete sentence result
            sessionResults.push({
                sentenceIndex: currentCueIndex,
                reference: referenceText,
                userInput: userText,
                stats: wordStats,
                time: sentenceTime,
                comparison: comparison
            });
            
            console.log('Session results so far:', sessionResults);

            // Move to next sentence if available
            if (currentCueIndex < vttCues.length - 1) {
                goToNextSentence();
                playCurrentSentence();
            } else {
                // Last sentence - show final results
                showFinalResult();
            }
        }

        // Get lesson ID from URL parameters
        function getLessonIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('lesson');
        }

        // Parse VTT file
        function parseVTT(vttText) {
            const lines = vttText.split('\n');
            const cues = [];
            let i = 0;

            // Skip header
            while (i < lines.length && !lines[i].includes('-->')) {
                i++;
            }

            while (i < lines.length) {
                const line = lines[i].trim();
                
                if (line.includes('-->')) {
                    const [startTime, endTime] = line.split('-->').map(t => t.trim());
                    const startSeconds = parseTimeToSeconds(startTime);
                    const endSeconds = parseTimeToSeconds(endTime);
                    
                    // Get the text (next non-empty line)
                    i++;
                    let text = '';
                    while (i < lines.length && lines[i].trim() !== '') {
                        if (text) text += ' ';
                        text += lines[i].trim();
                        i++;
                    }
                    
                    if (text) {
                        cues.push({
                            start: startSeconds,
                            end: endSeconds,
                            text: text
                        });
                    }
                }
                i++;
            }
            
            return cues;
        }

        // Convert time string to seconds
        function parseTimeToSeconds(timeStr) {
            const parts = timeStr.split(':');
            const seconds = parts[parts.length - 1].split('.');
            const sec = parseInt(seconds[0]);
            const ms = parseInt(seconds[1] || 0);
            
            if (parts.length === 3) {
                // HH:MM:SS.mmm
                const hours = parseInt(parts[0]);
                const minutes = parseInt(parts[1]);
                return hours * 3600 + minutes * 60 + sec + ms / 1000;
            } else {
                // MM:SS.mmm
                const minutes = parseInt(parts[0]);
                return minutes * 60 + sec + ms / 1000;
            }
        }

        // Load VTT file for lesson
        async function loadVTTFile(lessonId) {
            try {
                const vttUrl = `${CONFIG.audioBaseUrl}/A1L${lessonId.toString().padStart(2, '0')}.vtt`;
                console.log('Loading VTT from:', vttUrl);
                
                const response = await fetch(vttUrl);
                if (!response.ok) {
                    throw new Error(`VTT file not found: ${response.status}`);
                }
                
                const vttText = await response.text();
                console.log('VTT content:', vttText);
                
                const cues = parseVTT(vttText);
                console.log('Parsed cues:', cues);
                
                return cues;
            } catch (error) {
                console.error('Failed to load VTT file:', error);
                return [];
            }
        }

        // German character conversion
        function convertGermanChars(text) {
            return text
                .replace(/ae/g, 'ä')
                .replace(/oe/g, 'ö')
                .replace(/ue/g, 'ü')
                .replace(/Ae/g, 'Ä')
                .replace(/Oe/g, 'Ö')
                .replace(/Ue/g, 'Ü')
                // Replace B with ß, but only when B is NOT at the beginning of a word
                .replace(/\B([aeiouäöü])B/g, '$1ß')  // B after vowel, not at word start
                .replace(/([aeiouäöü])B([aeiouäöü])/g, '$1ß$2')  // B between vowels
                .replace(/([aeiouäöü])B$/g, '$1ß')  // B at end after vowel
                .replace(/([aeiouäöü])B(\s)/g, '$1ß$2');  // B before space after vowel
        }

        // Audio controls
        function togglePlayback() {
            if (vttCues.length === 0) {
                // No VTT cues, play normally
                if (isPlaying) {
                    audioPlayer.pause();
                } else {
                    audioPlayer.play().catch(error => {
                        console.log('Audio playback failed:', error);
                        alert('Audio could not be played. Please check your internet connection.');
                    });
                }
            } else {
                // Play current sentence
                playCurrentSentence();
            }
        }

        function playCurrentSentence() {
            if (currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
                const cue = vttCues[currentCueIndex];
                audioPlayer.currentTime = cue.start;
                audioPlayer.play().catch(error => {
                    console.log('Audio playback failed:', error);
                    alert('Audio could not be played. Please check your internet connection.');
                });
            }
        }

        function goToPreviousSentence() {
            if (currentCueIndex > 0) {
                currentCueIndex--;
                updateCurrentSentence();
                // Actually seek to the new sentence
                if (vttCues[currentCueIndex]) {
                    audioPlayer.currentTime = vttCues[currentCueIndex].start;
                }
            }
        }

        function goToNextSentence() {
            if (currentCueIndex < vttCues.length - 1) {
                currentCueIndex++;
                updateCurrentSentence();
                // Actually seek to the new sentence
                if (vttCues[currentCueIndex]) {
                    audioPlayer.currentTime = vttCues[currentCueIndex].start;
                }
            }
        }

        // Better sentence management
        function updateCurrentSentence() {
            updateNavigationButtons();
            updateSentenceInfo();
            updateCurrentReferenceText();
            
            // Reset input for new sentence
            if (userInput) userInput.value = '';
            updateLiveFeedback();
            
            // Reset timer for new sentence
            sentenceStartTime = null;
            hasStartedTyping = false;
            
            // Reset stats display
            if (statsSection) statsSection.style.display = 'none';
            if (checkBtn) checkBtn.style.display = 'inline-block';
            
            // Update height when content changes
            setTimeout(sendHeightToParent, 100);
        }

        function updateNavigationButtons() {
            if (prevBtn) prevBtn.disabled = (currentCueIndex <= 0);
            if (nextBtn) nextBtn.disabled = (currentCueIndex >= vttCues.length - 1);
        }

        function updateSentenceInfo() {
            if (sentenceInfo && vttCues.length > 0) {
                sentenceInfo.textContent = `Sentence ${currentCueIndex + 1} of ${vttCues.length}`;
            }
        }

        function updateCurrentReferenceText() {
            if (vttCues.length > 0 && currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
                referenceText = vttCues[currentCueIndex].text;
                if (referenceTextDiv) referenceTextDiv.textContent = referenceText;
            if (userInput) userInput.value = '';
            if (liveFeedback) liveFeedback.innerHTML = 'Live Feedback';
            if (statsSection) statsSection.style.display = 'none';
            if (checkBtn) checkBtn.style.display = 'inline-block';
            
            // Reset timer and stats
            sentenceStartTime = null;
            totalSessionTime = 0;
            hasStartedTyping = false;
            sessionResults = [];
            
            console.log('VTT cues loaded:', vttCues);
            
            // Update iframe height after loading
            setTimeout(sendHeightToParent, 500);
        }

        // Enhanced sequence alignment with missing word placeholders
        function compareTexts(reference, userText) {
            userText = convertGermanChars(userText);
            console.log('\n=== COMPARE TEXTS DEBUG ===');
            console.log('Reference:', reference);
            console.log('User text:', userText);
            
            const ignoreCase = ignoreCaseToggle ? ignoreCaseToggle.checked : true;
            const ignorePunctuation = true; // Always ignore punctuation now
            
            let refNormalized = reference;
            let userNormalized = userText;
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            // Handle multiple spaces in user input - normalize to single spaces
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            console.log('Normalized reference:', refNormalized);
            console.log('Normalized user:', userNormalized);
            
            // Get word arrays for smart alignment
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            console.log('Reference words:', refWords);
            console.log('User words:', userWords);
            
            // Perform sequence alignment to handle omissions/insertions
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            console.log('Alignment result:', alignment);
            
            // Build result with character-level feedback including placeholders
            const result = [];
            let correct = 0;
            let wrongPosition = 0;
            let wrong = 0;
            let extra = 0;
            let missing = 0;
            
            console.log('\n=== PROCESSING ALIGNMENT ===');
            // Process aligned sequences with proper word boundaries
            for (let i = 0; i < alignment.length; i++) {
                const item = alignment[i];
                console.log(`Processing item ${i}:`, item);
                
                // Add word boundary space before each item except the first
                if (i > 0) {
                    console.log('  -> Adding word boundary space');
                    result.push({ char: ' ', status: 'word-boundary' });
                }
                
                if (item.type === 'match') {
                    // Correct word in correct position
                    console.log('  -> Processing MATCH:', item.userWord);
                    for (let char of item.userWord) {
                        result.push({ char, status: 'correct' });
                        correct++;
                    }
                } else if (item.type === 'substitute') {
                   console.log('  -> Processing SUBSTITUTE:', item.userWord);

                    // Character-level diff for missing prefix OR suffix
                    const ref = item.refWord;
                    const user = item.userWord;

                    let missingPrefix = 0;
                    let missingSuffix = 0;

                    // Check for suffix match (user matches end of ref, e.g. "morgen" in "montagmorgen")
                    for (let idx = 1; idx <= ref.length; idx++) {
                        if (ref.slice(-idx) === user) {
                            missingPrefix = ref.length - idx;
                            break;
                        }
                    }
                    // Check for prefix match (user matches start of ref, e.g. "jahr" in "jahren")
                    if (missingPrefix === 0) {
                        for (let idx = 1; idx <= ref.length; idx++) {
                            if (ref.slice(0, idx) === user) {
                                missingSuffix = ref.length - idx;
                                break;
                            }
                        }
                    }

                    // Add underscores for missing prefix
                    if (missingPrefix > 0) {
                        for (let k = 0; k < missingPrefix; k++) {
                            if (k > 0) result.push({ char: ' ', status: 'char-space' });
                            result.push({ char: '_', status: 'missing' });
                            missing++;
                        }
                    }

                    // Render user's word (always in red)
                    for (let c = 0; c < user.length; c++) {
                        result.push({ char: user[c], status: 'wrong' });
                        wrong++;
                    }

                    // Add underscores for missing suffix
                    if (missingSuffix > 0) {
                        for (let k = 0; k < missingSuffix; k++) {
                            result.push({ char: ' ', status: 'char-space' });
                            result.push({ char: '_', status: 'missing' });
                            missing++;
                        }
                    }

                } else if (item.type === 'insert') {
                    // Extra word in user input
                    console.log('  -> Processing INSERT:', item.userWord);
                    for (let char of item.userWord) {
                        result.push({ char, status: 'extra' });
                        extra++;
                    }
                } else if (item.type === 'delete') {
                    // Missing word - show as individual underscores with spaces between them
                    console.log('  -> Processing DELETE (missing word):', item.refWord);
                    const wordLength = item.refWord.length;
                    
                    // Create individual underscores with spaces for each character
                    for (let k = 0; k < wordLength; k++) {
                        // Add character-level space before underscore (except for first character of word)
                        if (k > 0) {
                            result.push({ char: ' ', status: 'char-space' });
                        }
                        console.log('    -> Adding spaced underscore for missing character');
                        result.push({ char: '_', status: 'missing' });
                        missing++;
                    }
                }
            }
            
            console.log('\n=== FINAL RESULT ===');
            console.log('Result array length:', result.length);
            console.log('Result preview:', result.slice(0, 20));
            console.log('Stats:', { correct, wrongPosition, wrong, extra, missing });
            console.log('===================\n');
            
            return {
                chars: result,
                stats: { 
                    correct, 
                    wrongPosition, 
                    wrong, 
                    extra,
                    missing,
                    total: refNormalized.replace(/\s/g, '').length 
                }
            };
        }

        // Sequence alignment function
        function alignSequencesWithGaps(refWords, userWords) {
            // Simple dynamic programming alignment
            const N = refWords.length, M = userWords.length;
            const dp = Array.from({ length: N + 1 }, () => Array(M + 1).fill(0));

            const COST = { MATCH: 0, SUB: 3, INS: 2, DEL: 2 };

            // Build matrix
            for (let i = 0; i <= N; i++) dp[i][0] = i * COST.DEL;
            for (let j = 0; j <= M; j++) dp[0][j] = j * COST.INS;

            for (let i = 1; i <= N; i++) {
                for (let j = 1; j <= M; j++) {
                    const matchCost = dp[i - 1][j - 1] +
                        (refWords[i - 1] === userWords[j - 1] ? COST.MATCH : COST.SUB);
                    const delCost = dp[i - 1][j] + COST.DEL;
                    const insCost = dp[i][j - 1] + COST.INS;

                    dp[i][j] = Math.min(matchCost, delCost, insCost);
                }
            }

            // Back-trace to build alignment array
            let i = N, j = M, alignment = [];
            while (i > 0 || j > 0) {
                const current = dp[i][j];

                // Match / Substitute
                if (i > 0 && j > 0 &&
                    current === dp[i - 1][j - 1] +
                               (refWords[i - 1] === userWords[j - 1] ? COST.MATCH : COST.SUB)) {
                    alignment.unshift({
                        type: refWords[i - 1] === userWords[j - 1] ? 'match' : 'substitute',
                        refWord: refWords[i - 1],
                        userWord: userWords[j - 1]
                    });
                    i--; j--;
                    continue;
                }

                // Deletion
                if (i > 0 && current === dp[i - 1][j] + COST.DEL) {
                    alignment.unshift({ type: 'delete', refWord: refWords[i - 1], userWord: null });
                    i--;
                    continue;
                }

                // Insertion
                alignment.unshift({ type: 'insert', refWord: null, userWord: userWords[j - 1] });
                j--;
            }

            return alignment;
        }

        // Update live feedback
        function updateLiveFeedback() {
            if (!userInput || !liveFeedback) return;
            
            const userText = userInput.value;
            
            if (userText.trim() === '') {
                liveFeedback.innerHTML = 'Live Feedback';
                return;
            }
            
            const comparison = compareTexts(referenceText, userText);
            
            let feedbackHTML = '';
            comparison.chars.forEach(item => {
                let char = item.char;
                
                if (char === ' ') {
                    if (item.status === 'word-boundary') {
                        // Bigger space for word boundaries
                        char = '&nbsp;&nbsp;&nbsp;';
                    } else if (item.status === 'char-space') {
                        // Normal space between characters within missing words
                        char = '&nbsp;';
                    } else {
                        // Regular space
                        char = '&nbsp;';
                    }
                } else if (char === '\n') {
                    char = '<br>';
                }
                
                feedbackHTML += `<span class="char-${item.status}">${char}</span>`;
            });
            
            liveFeedback.innerHTML = feedbackHTML;
        }

        // Update progress bar
        function updateProgress() {
            if (!audioPlayer || !timeDisplay || !progressBar) return;
            
            const currentTime = audioPlayer.currentTime;
            const duration = audioPlayer.duration;
            
            if (duration) {
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
                
                const formatTime = (time) => {
                    const minutes = Math.floor(time / 60);
                    const seconds = Math.floor(time % 60);
                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                };
                
                timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
            }
        }

        // Calculate word-based statistics properly
        function calculateWordStats(comparison) {
            const ignoreCase = ignoreCaseToggle ? ignoreCaseToggle.checked : true;
            const ignorePunctuation = true;
            
            let refNormalized = referenceText;
            let userNormalized = userInput.value;
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            // Normalize spaces
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            // Perform alignment to get word-level statistics
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            let correctWords = 0;
            let wrongWords = 0;
            let totalWords = refWords.length;
            
            // Count based on alignment results
            alignment.forEach(item => {
                if (item.type === 'match') {
                    correctWords++;
                } else if (item.type === 'substitute' || item.type === 'delete') {
                    wrongWords++;
                }
                // Note: 'insert' items (extra words) don't count toward reference total
            });
            
            return {
                correctWords,
                wrongWords,
                totalWords
            };
        }

        // Better final result calculation
        function showFinalResult() {
            if (!userInput) return;
            
            // Process current sentence if not already processed
            if (userInput.value.trim() && sessionResults.length === currentCueIndex) {
                let sentenceTime = 0;
                if (hasStartedTyping && sentenceStartTime) {
                    sentenceTime = (Date.now() - sentenceStartTime) / 1000;
                    totalSessionTime += sentenceTime;
                }

                const userText = userInput.value;
                const comparison = compareTexts(referenceText, userText);
                const wordStats = calculateWordStats(comparison);
                
                sessionResults.push({
                    sentenceIndex: currentCueIndex,
                    reference: referenceText,
                    userInput: userText,
                    stats: wordStats,
                    time: sentenceTime,
                    comparison: comparison
                });
            }
            
            // Calculate overall stats from sessionResults
            let totalCorrectWords = 0;
            let totalWrongWords = 0;
            let totalWords = 0;
            
            sessionResults.forEach(result => {
                totalCorrectWords += result.stats.correctWords;
                totalWrongWords += result.stats.wrongWords;
                totalWords += result.stats.totalWords;
            });
            
            console.log('Final calculation:', {
                totalCorrectWords,
                totalWrongWords,
                totalWords,
                sessionResults
            });
            
            // Calculate accuracy
            const accuracy = totalWords > 0 ? Math.round((totalCorrectWords / totalWords) * 100) : 0;
            
            // Update display
            if (accuracyPercent) accuracyPercent.textContent = accuracy + '%';
            if (correctWords) correctWords.textContent = totalCorrectWords;
            if (wrongWords) wrongWords.textContent = totalWrongWords;

            // Update timing display
            const timeElement = document.getElementById('timeTaken');
            if (timeElement) {
                timeElement.textContent = formatTime(totalSessionTime);
            }
            
            if (statsSection) statsSection.style.display = 'grid';
            if (checkBtn) checkBtn.style.display = 'none';
            
            console.log(`Final stats: ${accuracy}% accuracy, ${totalCorrectWords}/${totalWords} words correct, ${formatTime(totalSessionTime)} total time`);
            
            // Update iframe height when stats appear
            setTimeout(sendHeightToParent, 100);
        }
        
        // Format time in MM:SS format
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function resetDictation() {
            if (userInput) userInput.value = '';
            if (liveFeedback) liveFeedback.innerHTML = 'Live Feedback';
            if (statsSection) statsSection.style.display = 'none';
            if (checkBtn) checkBtn.style.display = 'inline-block';
            
            // Reset all session data
            sentenceStartTime = null;
            totalSessionTime = 0;
            hasStartedTyping = false;
            sessionResults = [];
            currentCueIndex = 0;
            
            // Reset to first sentence
            updateCurrentSentence();
            
            // Update iframe height
            setTimeout(sendHeightToParent, 100);
        }

        function showAnswer() {
            if (referenceTextDiv) {
                referenceTextDiv.style.display = 'block';
                setTimeout(() => {
                    referenceTextDiv.style.display = 'none';
                    sendHeightToParent();
                }, 10000);
                sendHeightToParent();
            }
        }
    </script>
</body>
</html>Text;
            }
        }

        // Handle time updates to auto-pause at sentence end
        function handleTimeUpdate() {
            updateProgress();
            
            if (vttCues.length > 0 && isPlaying) {
                const currentTime = audioPlayer.currentTime;
                const currentCue = vttCues[currentCueIndex];
                
                if (currentCue && currentTime >= currentCue.end) {
                    audioPlayer.pause();
                }
            }
        }

        // Load lesson
        async function loadLesson(lessonId) {
            console.log(`Loading lesson ${lessonId}...`);
            
            if (lessonInfo) lessonInfo.textContent = 'Loading lesson...';
            if (playBtn) {
                playBtn.textContent = '⏳';
                playBtn.disabled = true;
            }
            
            // Load VTT file only
            const cues = await loadVTTFile(lessonId);
            
            if (cues.length === 0) {
                console.error(`Failed to load VTT for lesson ${lessonId}`);
                if (lessonInfo) lessonInfo.textContent = `Failed to load lesson ${lessonId}`;
                return;
            }
            
            vttCues = cues;
            currentCueIndex = 0;
            
            // Use first sentence from VTT as reference
            referenceText = vttCues[0].text;
            updateNavigationButtons();
            updateSentenceInfo();
            
            // Set up audio player with direct audio URL
            const audioUrl = `${CONFIG.audioBaseUrl}/A1L${lessonId.toString().padStart(2, '0')}.mp3`;
            if (audioPlayer) {
                audioPlayer.src = audioUrl;
                
                audioPlayer.addEventListener('loadedmetadata', () => {
                    if (playBtn) {
                        playBtn.textContent = '';
                        playBtn.classList.remove('playing');
                        playBtn.disabled = false;
                    }
                    updateProgress();
                    console.log('Audio metadata loaded successfully');
                }, { once: true });
                
                audioPlayer.addEventListener('error', (e) => {
                    if (playBtn) {
                        playBtn.textContent = '❌';
                        playBtn.disabled = true;
                    }
                    console.error('Failed to load audio:', audioUrl, e);
                }, { once: true });
            }
            
            // Update lesson info
            if (lessonInfo) {
                lessonInfo.innerHTML = `
                    <strong>German Dictation - Lesson ${lessonId}</strong><br>
                    <span style="color: #888;">
                        ${vttCues.length} sentences
                    </span>
                `;
            }
            
            if (referenceTextDiv) referenceTextDiv.textContent = reference