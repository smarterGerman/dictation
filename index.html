<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>German Dictation Tool</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fdfdfd;
            color: #1f2937;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 100%;
            width: 100%;
            margin: 0 auto;
            background: transparent;
        }

        .content { 
            padding: 0; 
            width: 100%; 
        }

        /* ----- AUDIO SECTION ---------------------------------------------- */
        .audio-section {
            padding: 20px;
            margin-bottom: 24px;
            background: linear-gradient(135deg, #e0f2fe 0%, #f3e5f5 100%);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: center;
            color: #374151;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            width: 100%;
            overflow: visible !important;
        }
        
        .sentence-info { 
            margin-bottom: 24px; 
            font-size: 15px; 
            color: #6b7280; 
            font-weight: 500; 
        }

        .audio-controls { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            gap: 12px; 
            margin-bottom: 28px; 
            flex-wrap: nowrap; 
            overflow: visible !important;

        }

        .loading-spinner {
            position: absolute;
            width: 64px;
            height: 64px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            display: none; /* FIX: Start hidden, control via JS */
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .play-btn .loading-spinner {
            display: none;
        }

        .play-btn.loading .loading-spinner {
            display: block;
        }

        .play-btn::before { 
            content:''; 
            position:absolute; 
            left:50%; 
            top:50%; 
            transform:translate(-50%,-50%);
            z-index: 2;
        }

        .nav-btn,
        .play-btn,
        .toggle-btn { 
            border: none; 
            border-radius: 50%; 
            cursor: pointer; 
            transition: all .3s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            outline: none;
            position: relative;
        }

        .nav-btn,
        .toggle-btn {
            width: 52px; 
            height: 52px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            font-size: 18px;
            color: #6b7280;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .nav-btn:hover:not(:disabled),
        .toggle-btn:hover { 
            transform: translateY(-2px); 
            background: rgba(255, 255, 255, 1);
            color: #374151;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }
        
        .nav-btn:disabled { 
            opacity:0.3; 
            cursor:not-allowed; 
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(168, 85, 247, 0.3), 0 0 0 3px rgba(168, 85, 247, 0.4), 0 0 20px rgba(168, 85, 247, 0.6);
            transform: translateY(-1px);
        }

        .toggle-btn.active:hover {
            background: linear-gradient(135deg, #9333ea 0%, #db2777 100%);
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.4), 0 0 0 3px rgba(168, 85, 247, 0.5), 0 0 25px rgba(168, 85, 247, 0.7);
            transform: translateY(-2px);
        }

        /* Speed button colors - Traffic Light */
        .toggle-btn.speed-100 {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(34, 197, 94, 0.3);
        }

        .toggle-btn.speed-100:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            box-shadow: 0 8px 24px rgba(34, 197, 94, 0.4);
        }

        .toggle-btn.speed-75 {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(251, 191, 36, 0.3);
        }

        .toggle-btn.speed-75:hover {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 8px 24px rgba(251, 191, 36, 0.4);
        }

        .toggle-btn.speed-50 {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
        }

        .toggle-btn.speed-50:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            box-shadow: 0 8px 24px rgba(239, 68, 68, 0.4);
        }

        /* Hint tooltip styles */
        .hint-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1f2937;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            white-space: normal;
            max-width: 250px; 
            text-align: left;
            word-wrap: break-word; 
            z-index: 1000;
            margin-top: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .hint-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: #1f2937;
        }

        .hint-tooltip.show {
            opacity: 1;
            pointer-events: auto;
        }

        .play-btn {
            position: relative;
            width: 72px; 
            height: 72px;
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.3);
            font-size: 28px;
            color: white;
        }
        
        .play-btn:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 12px 32px rgba(168, 85, 247, 0.4);
        }
        
        .play-btn:disabled{
            opacity:.5;
            cursor:not-allowed;
        }
        
        .play-btn::before { 
            content:''; 
            position:absolute; 
            left:50%; 
            top:50%; 
            transform:translate(-50%,-50%); 
        }
        
        .play-btn.playing::before { 
            width:4px;
            height:20px;
            background:white;
            box-shadow:8px 0 0 white; 
        }
        
        .play-btn:not(.playing)::before { 
            border-left:12px solid white; 
            border-top:8px solid transparent; 
            border-bottom:8px solid transparent; 
        }

        #timeDisplay { 
            min-width:110px; 
            font-size:16px; 
            color:#6b7280; 
            font-weight:500; 
            margin-left: 16px; 
            margin-right: 16px;
        }
        
        .progress-container { 
             flex-grow: 1; /* Allows it to take up available space in the flex container */
    max-width: 320px; /* Limits its maximum width to avoid being too wide on large screens */
    height: 8px;
    background: rgba(0, 0, 0, 0.3); /* Changed to a darker, more visible background */
    border-radius: 20px;
    overflow: hidden;
    margin: 0 10px; /* Add horizontal margin to separate from buttons/time */ 
        }
        
        .progress-bar { 
            height:100%; 
            width:0%; 
            background:linear-gradient(90deg, #a855f7, #ec4899); 
            border-radius:20px; 
            transition:width .3s ease; 
        }

        /* ----- INPUT / FEEDBACK ------------------------------------------- */
        .input-area { 
            display:flex; 
            flex-direction:column; 
            gap:20px; 
            padding: 0; 
        }
        
        .input-field {
            width:100%; 
            min-height:100px; 
            padding:18px;
            background: linear-gradient(135deg, #fef7ff 0%, #f0f9ff 100%); 
            color:#374151;
            border:2px solid #e879f9; 
            border-radius: 16px;
            font-size:16px; 
            line-height:1.5; 
            resize:vertical;
            transition:all .3s ease;
            box-shadow: 0 4px 16px rgba(232, 121, 249, 0.1);
        }
        
        .input-field:focus { 
            border-color:#c084fc; 
            box-shadow:0 0 0 4px rgba(192, 132, 252, 0.15), 0 4px 16px rgba(232, 121, 249, 0.2); 
            outline:none; 
            transform: translateY(-1px);
        }

        .input-field::placeholder {
            color: #9CA3AF; /* A lighter grey color */
            opacity: 1;    /* Ensures full opacity across browsers (Firefox defaults lower) */
            transition: color 0.3s ease; /* Optional: smooth transition if placeholder changes */
}
        
        .live-feedback {
            min-height:100px; 
            padding:18px;
            background: linear-gradient(135deg, #ecfdf5 0%, #fef3ff 100%); 
            border: none; 
            border-radius: 16px;
            font-size:28px; 
            line-height:1.5; 
            white-space:pre-wrap; 
            word-break:break-word;
            color: #9ca3af;
            box-shadow: 0 4px 16px rgba(167, 139, 250, 0.1);
        }

        /* feedback colors */
        .char-correct{color:#059669;font-weight:500;} 
        .char-wrong-position{color:#d97706;font-weight:500;} 
        .char-wrong{color:#dc2626;text-decoration:underline;font-weight:500;} 
        .char-missing{color:#d97706;font-style:italic;font-weight:500;} 
        .char-extra{color:#2563eb;font-weight:500;} 
        .char-word-boundary,.char-char-space{color:#9ca3af;}

        /* ----- OPTIONS ----------------------------------------------------- */
        .options { 
            display: none;
        }

        /* ----- STATS & CONTROLS ------------------------------------------- */
        .stats-section{
            margin:32px 0 0 0;
            padding-top:24px;
            border-top:1px solid #f3f4f6;
        }
        
        .stats{
            display:grid;
            grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
            gap:16px;
            margin-bottom:24px;
        }
        
        .stat-item{
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border:none;
            border-radius:16px;
            padding:24px;
            text-align:center;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: all .3s ease;
        }
        
        .stat-item:hover{
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        }
        
        .stat-value{
            font-size:36px;
            font-weight:700;
            color:#e879f9;
            margin-bottom:8px;
            display:block;
        }
        
        .stat-label{
            font-size:14px;
            font-weight:500;
            color:#6b7280;
        }

        .reference-text{
            margin-top:24px;
            padding:20px;
            background:#fef9e7;
            border:1px solid #fcd34d;
            border-radius:8px;
            color:#92400e;
            display:none;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

       /* ----- RESPONSIVE -------------------------------------------------- */
       @media(max-width:768px){
    body { padding: 10px; }
    .audio-section{ padding: 15px; }
    .input-field, .live-feedback{ padding: 15px; font-size: 15px; } /* Your existing size preference for mobile text */

    /* Hide progress bar on mobile */
    .progress-container {
        display: none; /* Hides the progress bar on small screens */
    }

    .audio-controls{
        gap: 8px;
        flex-wrap: wrap; /* Allows items to move to next line */
        justify-content: center; /* Centers items when they wrap */
        padding: 0 5px; /* Small horizontal padding for controls */
    }

    /* For the Previous/Next buttons and the Aa/100/?/X toggle buttons */
    .nav-btn, .toggle-btn{
        width: 44px; /* Baseline size for good touch target */
        height: 44px; /* Baseline size for good touch target */
        font-size: 16px; /* Icon/text size */
        flex-shrink: 0; /* PREVENTS THESE BUTTONS FROM SHRINKING */
        flex-grow: 0; /* Ensures they don't grow */
        flex-basis: auto; /* Standard for fixed-size items */
    }

    /* For the Play/Pause button */
    .play-btn{
        width: 64px; /* Larger size */
        height: 64px; /* Larger size */
        font-size: 24px; /* Icon size */
        flex-shrink: 0; /* PREVENTS THIS BUTTON FROM SHRINKING */
        flex-grow: 0; /* Ensures it doesn't grow */
        flex-basis: auto; /* Standard for fixed-size items */
    }

    /* For the time display (0:00 / 0:00) */
    #timeDisplay {
        min-width: unset; /* IMPORTANT: REMOVES FIXED MINIMUM WIDTH, allows it to shrink */
        font-size: 14px; /* OPTIONAL: Smaller font size for mobile fit */
        margin: 0 5px; /* REDUCED MARGINS for more space */
        flex-grow: 1; /* Allows it to take up remaining space on its line */
        flex-shrink: 1; /* Allows it to shrink if needed */
        flex-basis: auto; /* Helps with flexible width */
        text-align: center; /* Centers text if it's on its own line */
    }

    .controls{ flex-direction: column; } /* Existing rule for stats section controls (if still in use) */
    .control-btn{ width: 100%; } /* Existing rule for stats section controls (if still in use) */
}

        /* Add this new style for your 'X' button */
    .toggle-btn.end-button { /* Use .toggle-btn to ensure specificity if needed */
        background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); /* Red background */
        color: white;
        font-size: 1.5em; /* Make the 'X' larger */
        font-weight: bold;
        line-height: 1; /* Ensures X is vertically centered */
        padding: 8px 12px; /* Adjust padding if needed to fit 'X' */
    }

    .toggle-btn.end-button:hover {
        background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%); /* Darker red on hover */
        transform: translateY(-2px); /* Keep consistent hover effect */
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <!-- AUDIO SECTION -->
            <div class="audio-section">
                <div class="audio-controls">
                    <button class="nav-btn" id="prevBtn" title="Previous sentence">‹</button>
                    <button class="play-btn" id="playBtn">
                        <div class="loading-spinner" id="loadingSpinner"></div>
                    </button>
                    <button class="nav-btn" id="nextBtn" title="Next sentence">›</button>
                    <button class="toggle-btn" id="ignoreCaseBtn" title="Ignore Capitalization">Aa</button>
                    <button class="toggle-btn" id="speedBtn" title="Playback Speed">100</button>
                    <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                    <span id="timeDisplay">0:00 / 0:00</span>
                    <button class="toggle-btn" id="hintBtn" title="Show expected sentence">?</button>
                    <button class="toggle-btn" id="endDictationBtn" title="End dictation & show stats">X</button>
                </div>
                <audio id="audioPlayer" preload="auto"></audio>
            </div>

            <!-- TEXT & FEEDBACK -->
            <div class="text-section">
                <div class="input-area">
                    <div class="live-feedback" id="liveFeedback">Live Feedback</div>
                    <textarea class="input-field" id="userInput" placeholder="" autofocus></textarea>
                </div>

                <div class="options">
                    <!-- Options moved to audio controls -->
                </div>

                <div class="reference-text" id="referenceText"></div>
            </div>

            <!-- STATS & CONTROLS -->
            <div class="stats-section">
                <div class="stats" id="statsSection" style="display:none;">
                    <div class="stat-item"><span class="stat-label">Accuracy</span><span class="stat-value" id="accuracyPercent">0%</span></div>
                    <div class="stat-item"><span class="stat-label">Correct Words</span><span class="stat-value" id="correctWords">0</span></div>
                    <div class="stat-item"><span class="stat-label">Wrong Words</span><span class="stat-value" id="wrongWords">0</span></div>
                    <div class="stat-item"><span class="stat-label">Time Taken</span><span class="stat-value" id="timeTaken">0:00</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function sendHeightToParent() {
            const height = document.body.scrollHeight;
            if (window.parent !== window) {
                window.parent.postMessage({ frameHeight: height }, '*');
            }
        }

        window.addEventListener('load', sendHeightToParent);
        window.addEventListener('resize', sendHeightToParent);

        let referenceText = '';
        let isPlaying = false;
        let vttCues = [];
        let currentCueIndex = 0;
        let allLessons = {}; // Store all lesson data
        let currentLessonId = '';
        let hasStartedTyping = false;
        let sentenceStartTime = null;
        let totalSessionTime = 0;
        let sessionResults = [];
        let ignoreCaseActive = true; // Default state
        let currentSpeed = 1.0; // Default speed (100%)

        // FIX: Move initialPlaceholderText to global scope
        const initialPlaceholderText = "Press SHIFT+CTRL/CMD+ENTER to play/pause audio.\nType what you hear here...\n(Use ae for ä, oe for ö, ue for ü, B for ß)";

        const CONFIG = {
            lessonsUrl: 'https://raw.githubusercontent.com/smarterGerman/dictation/main/lessons/lessons.json'
        };

        let audioPlayer, playBtn, progressBar, timeDisplay, referenceTextDiv, loadingSpinner, statsSection;
        let userInput, liveFeedback, accuracyPercent, correctWords, wrongWords;
        let endDictationBtn, resetBtn, ignoreCaseBtn, hintBtn, speedBtn;
        let prevBtn, nextBtn, sentenceInfo;

        window.addEventListener('load', function() {
            audioPlayer = document.getElementById('audioPlayer');
            playBtn = document.getElementById('playBtn');
            progressBar = document.getElementById('progressBar');
            timeDisplay = document.getElementById('timeDisplay');
            referenceTextDiv = document.getElementById('referenceText');
            loadingSpinner = document.getElementById('loadingSpinner');
            statsSection = document.getElementById('statsSection');
            userInput = document.getElementById('userInput');
            
            // Set the initial placeholder text when the page loads
            if (userInput) {
                userInput.placeholder = initialPlaceholderText;
            }
            liveFeedback = document.getElementById('liveFeedback');
            accuracyPercent = document.getElementById('accuracyPercent');
            correctWords = document.getElementById('correctWords');
            wrongWords = document.getElementById('wrongWords');
            endDictationBtn = document.getElementById('endDictationBtn');
            ignoreCaseBtn = document.getElementById('ignoreCaseBtn');
            speedBtn = document.getElementById('speedBtn');
            hintBtn = document.getElementById('hintBtn');
            prevBtn = document.getElementById('prevBtn');
            nextBtn = document.getElementById('nextBtn');
            sentenceInfo = document.getElementById('sentenceInfo');

            if (playBtn) playBtn.addEventListener('click', togglePlayback);
            if (prevBtn) prevBtn.addEventListener('click', goToPreviousSentence);
            if (nextBtn) nextBtn.addEventListener('click', goToNextSentence);
            if (userInput) {
                userInput.addEventListener('input', handleUserInput);
                userInput.addEventListener('keydown', handleKeyDown);
            }
            if (endDictationBtn) endDictationBtn.addEventListener('click', showFinalResult);
            if (ignoreCaseBtn) {
                ignoreCaseBtn.addEventListener('click', toggleIgnoreCase);
                // Set initial state
                if (ignoreCaseActive) {
                    ignoreCaseBtn.classList.add('active');
                }
            }
            if (speedBtn) {
                speedBtn.addEventListener('click', toggleSpeed);
                // Set initial green color for 100% speed
                speedBtn.classList.add('speed-100');
            }
            if (hintBtn) {
                hintBtn.addEventListener('click', showHint);
            }

            if (audioPlayer) {
                audioPlayer.addEventListener('play', () => {
                    isPlaying = true;
                    if (playBtn) {
                        playBtn.classList.add('playing');
                    }
                    // Auto-focus input field when audio starts
                    if (userInput) {
                        userInput.focus();
                    }
                });
                audioPlayer.addEventListener('pause', () => {
                    isPlaying = false;
                    if (playBtn) {
                        playBtn.classList.remove('playing');
                    }
                });
                audioPlayer.addEventListener('timeupdate', handleTimeUpdate);
            }

            window.addEventListener('keydown', handleGlobalKeyDown);
            const lessonId = getLessonIdFromUrl() || 'A1L01';
            loadAllLessons().then(() => {
                loadLesson(lessonId);
            });
            window.focus();
            console.log('Main window load event completed, focus attempted.'); // For debugging
            setTimeout(sendHeightToParent, 500);
        });

        function toggleSpeed() {
            // Remove all speed classes first
            if (speedBtn) {
                speedBtn.classList.remove('speed-100', 'speed-75', 'speed-50');
            }
            
            // Cycle through speeds: 100% → 75% → 50% → 100%
            if (currentSpeed === 1.0) {
                currentSpeed = 0.75;
                speedBtn.textContent = '75';
                speedBtn.classList.add('speed-75');
            } else if (currentSpeed === 0.75) {
                currentSpeed = 0.5;
                speedBtn.textContent = '50';
                speedBtn.classList.add('speed-50');
            } else {
                currentSpeed = 1.0;
                speedBtn.textContent = '100';
                speedBtn.classList.add('speed-100');
            }
            
            // Apply speed to audio player
            if (audioPlayer) {
                audioPlayer.playbackRate = currentSpeed;
            }
        }

        function toggleIgnoreCase() {
            ignoreCaseActive = !ignoreCaseActive;
            if (ignoreCaseBtn) {
                if (ignoreCaseActive) {
                    ignoreCaseBtn.classList.add('active');
                } else {
                    ignoreCaseBtn.classList.remove('active');
                }
            }
            updateLiveFeedback();
        }

        function handleUserInput(e) {
            // Hide hint tooltip when user starts typing
            hideHint();
            
            if (!hasStartedTyping && e.target.value.trim().length > 0) {
                hasStartedTyping = true;
                sentenceStartTime = Date.now();
            }
            
            const cursorPos = e.target.selectionStart;
            const convertedText = convertGermanChars(e.target.value);
            if (convertedText !== e.target.value) {
                e.target.value = convertedText;
                e.target.setSelectionRange(cursorPos, cursorPos);
            }
            updateLiveFeedback();
            setTimeout(sendHeightToParent, 100);
        }

        function handleGlobalKeyDown(e) {
            console.log('Global keydown detected:', e.key, 'Shift:', e.shiftKey, 'Ctrl/Cmd:', (e.ctrlKey || e.metaKey)); // ADD THIS LINE
            // Shortcuts always enabled, even while typing

            // Hint shortcut: Shift + Ctrl/Cmd + ß (German), / (US), , (French)
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === 'ß') {
                e.preventDefault();
                showHint();
                if (hintBtn) hintBtn.focus();
                return;
            }
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === '/') {
                e.preventDefault();
                showHint();
                if (hintBtn) hintBtn.focus();
                return;
            }
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === ',') {
                e.preventDefault();
                showHint();
                if (hintBtn) hintBtn.focus();
                return;
            }

            // Play/Pause (start dictation): Shift + Ctrl/Cmd + Enter
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                console.log('Shortcut for togglePlayback activated.'); //
                togglePlayback();
                return;
            }

            // Sentence navigation: Shift + Ctrl/Cmd + Arrow keys
            if (e.shiftKey && (e.ctrlKey || e.metaKey)) {
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        goToPreviousSentence();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        goToNextSentence();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        playCurrentSentence();
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        toggleSpeed();
                        break;
                }
            }
        }

        function handleKeyDown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                processCurrentSentenceAndAdvance();
            }
        }

        function processCurrentSentenceAndAdvance() {
            if (!userInput.value.trim()) {
                playCurrentSentence();
                return;
            }

            let sentenceTime = 0;
            if (hasStartedTyping && sentenceStartTime) {
                sentenceTime = (Date.now() - sentenceStartTime) / 1000;
                totalSessionTime += sentenceTime;
            }

            const userText = userInput.value;
            const comparison = compareTexts(referenceText, userText);
            const wordStats = calculateWordStats(comparison);
            
            sessionResults.push({
                sentenceIndex: currentCueIndex,
                reference: referenceText,
                userInput: userText,
                stats: wordStats,
                time: sentenceTime,
                comparison: comparison
            });

            if (currentCueIndex < vttCues.length - 1) {
                goToNextSentence();
                playCurrentSentence();
            } else {
                showFinalResult();
            }
        }

        function getLessonIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('lesson');
        }

        async function loadAllLessons() {
            try {
                const response = await fetch(CONFIG.lessonsUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load lessons: ${response.status}`);
                }
                allLessons = await response.json();
            } catch (error) {
                console.error('Failed to load lessons:', error);
                if (lessonInfo) lessonInfo.textContent = 'Failed to load lessons data';
            }
        }

        function parseVTT(vttText) {
            const lines = vttText.split('\n');
            const cues = [];
            let i = 0;

            while (i < lines.length && !lines[i].includes('-->')) {
                i++;
            }

            while (i < lines.length) {
                const line = lines[i].trim();
                
                if (line.includes('-->')) {
                    const [startTime, endTime] = line.split('-->').map(t => t.trim());
                    const startSeconds = parseTimeToSeconds(startTime);
                    const endSeconds = parseTimeToSeconds(endTime);
                    
                    i++;
                    let text = '';
                    while (i < lines.length && lines[i].trim() !== '') {
                        if (text) text += ' ';
                        text += lines[i].trim();
                        i++;
                    }
                    
                    if (text) {
                        cues.push({
                            start: startSeconds,
                            end: endSeconds,
                            text: text
                        });
                    }
                }
                i++;
            }
            
            return cues;
        }

        function parseTimeToSeconds(timeStr) {
            const parts = timeStr.split(':');
            const seconds = parts[parts.length - 1].split('.');
            const sec = parseInt(seconds[0]);
            const ms = parseInt(seconds[1] || 0);
            
            if (parts.length === 3) {
                const hours = parseInt(parts[0]);
                const minutes = parseInt(parts[1]);
                return hours * 3600 + minutes * 60 + sec + ms / 1000;
            } else {
                const minutes = parseInt(parts[0]);
                return minutes * 60 + sec + ms / 1000;
            }
        }

        async function loadVTTFromUrl(vttUrl) {
            try {
                const response = await fetch(vttUrl);
                if (!response.ok) {
                    throw new Error(`VTT file not found: ${response.status}`);
                }
                
                const vttText = await response.text();
                const cues = parseVTT(vttText);
                return cues;
            } catch (error) {
                console.error('Failed to load VTT file:', error);
                return [];
            }
        }

        function convertGermanChars(text) {
            return text
                .replace(/ae/g, 'ä')
                .replace(/oe/g, 'ö')
                .replace(/ue/g, 'ü')
                .replace(/Ae/g, 'Ä')
                .replace(/Oe/g, 'Ö')
                .replace(/Ue/g, 'Ü')
                .replace(/\B([aeiouäöü])B/g, '$1ß')
                .replace(/([aeiouäöü])B([aeiouäöü])/g, '$1ß$2')
                .replace(/([aeiouäöü])B$/g, '$1ß')
                .replace(/([aeiouäöü])B(\s)/g, '$1ß$2');
        }
        
        function togglePlayback() {
           console.log(`[DEBUG] Play/Pause button tapped. IsPaused: ${audioPlayer.paused}. Current Network State: ${audioPlayer.networkState}.`);
            console.log('togglePlayback called.');
            if (vttCues.length === 0) {
                // No VTT cues, just play/pause the entire audio
                if (isPlaying) {
                    audioPlayer.pause();
                } else {
                    audioPlayer.play().catch(error => {
                        console.log('Audio playback failed:', error);
                        alert('Audio could not be played. Please check your internet connection.');
                    });
                }
            } else {
                // VTT cues available, toggle play/pause for current sentence
                if (isPlaying) {
                    audioPlayer.pause();
                } else {
                    playCurrentSentence();
                }
            }
        }

        function playCurrentSentence() {
            if (currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
                const cue = vttCues[currentCueIndex];
                audioPlayer.currentTime = cue.start;
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('[DEBUG] Playback promise resolved (audio started).');
                    }).catch(error => {
                        console.error('Audio Playback Promise Rejected:', {
                            name: error.name,
                            message: error.message,
                            networkState: audioPlayer.networkState,
                            errorObject: error // Log the full error object
                        });
                        // Show user-friendly error message
                        alert('Audio could not be played. Please check your internet connection.');
                    });
                }
            }
        }

        function goToPreviousSentence() {
            if (currentCueIndex > 0) {
                currentCueIndex--;
                updateCurrentSentence();
                if (vttCues[currentCueIndex]) {
                    audioPlayer.currentTime = vttCues[currentCueIndex].start;
                }
            }
        }

        function goToNextSentence() {
            if (currentCueIndex < vttCues.length - 1) {
                currentCueIndex++;
                updateCurrentSentence();
                if (vttCues[currentCueIndex]) {
                    audioPlayer.currentTime = vttCues[currentCueIndex].start;
                }
            }
        }

        function updateCurrentSentence() {
            updateNavigationButtons();
            updateSentenceInfo();
            updateCurrentReferenceText();
            
            // Hide any existing hint tooltip
            hideHint();
            
            if (userInput) userInput.value = '';
            // Handle placeholder visibility based on sentence index
            if (userInput) {
                // If it's the 1st or 2nd sentence (currentCueIndex 0 or 1)
                if (currentCueIndex < 2) {
                    userInput.placeholder = initialPlaceholderText;
                } else {
                    // For the 3rd sentence (index) and onwards, remove the detailed instructions
                    userInput.placeholder = "Type what you hear here...";
                }
            }
            updateLiveFeedback();
            
            sentenceStartTime = null;
            hasStartedTyping = false;
            
            if (statsSection) statsSection.style.display = 'none';
            
            setTimeout(sendHeightToParent, 100);
        }

        function updateNavigationButtons() {
            if (prevBtn) prevBtn.disabled = (currentCueIndex <= 0);
            if (nextBtn) nextBtn.disabled = (currentCueIndex >= vttCues.length - 1);
        }

        function updateSentenceInfo() {
            if (sentenceInfo && vttCues.length > 0) {
                sentenceInfo.textContent = `Sentence ${currentCueIndex + 1} of ${vttCues.length}`;
            }
        }

        function updateCurrentReferenceText() {
            if (vttCues.length > 0 && currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
                referenceText = vttCues[currentCueIndex].text;
                if (referenceTextDiv) referenceTextDiv.textContent = referenceText;
            }
        }

        function handleTimeUpdate() {
            updateProgress();
            
            if (vttCues.length > 0 && isPlaying) {
                const currentTime = audioPlayer.currentTime;
                const currentCue = vttCues[currentCueIndex];
                
                if (currentCue && currentTime >= currentCue.end) {
                    audioPlayer.pause();
                }
            }
        }

        async function loadLesson(lessonId) {
            // FIX: Show loading spinner properly
            if (loadingSpinner) {
                loadingSpinner.style.display = 'block';
            }
            if (playBtn) {
                // FIX: Don't set textContent, it conflicts with CSS ::before
                playBtn.classList.add('loading');
                playBtn.disabled = true;
            }

            // Check if lesson exists
            if (!allLessons[lessonId]) {
                console.error(`Lesson ${lessonId} not found`);
                if (lessonInfo) lessonInfo.textContent = 'Failed to load lessons data';
                return;
            }

            currentLessonId = lessonId;
            const lessonData = allLessons[lessonId];
            
            const cues = await loadVTTFromUrl(lessonData.vttUrl);
            
            if (cues.length === 0) {
                console.error(`Failed to load VTT for lesson ${lessonId}`);
                if (loadingSpinner) {
                    loadingSpinner.style.display = 'none';
                }
                return;
            }
            
            vttCues = cues;
            currentCueIndex = 0;
            
            referenceText = vttCues[0].text;
            updateNavigationButtons();
            
            if (audioPlayer) {
                audioPlayer.src = lessonData.audioUrl;
                console.log(`[DEBUG] Attempting to load audio: ${lessonData.audioUrl.substring(lessonData.audioUrl.lastIndexOf('/') + 1)}. Current Network State: ${audioPlayer.networkState}.`);
                
                audioPlayer.addEventListener('loadedmetadata', () => {
                    console.log(`[DEBUG] Metadata loaded. Duration: ${audioPlayer.duration.toFixed(2)}s. Network State: ${audioPlayer.networkState}.`);
                    if (playBtn) {
                        // FIX: Remove loading class instead of setting textContent
                        playBtn.classList.remove('loading', 'playing');
                        playBtn.disabled = false;
                    }
                    // Set the current speed when audio loads
                    audioPlayer.playbackRate = currentSpeed;
                    updateProgress();
                    // FIX: Hide loading spinner properly
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                }, { once: true });
                
                audioPlayer.addEventListener('error', (e) => {
                    const error = e.target.error;
                    console.error('Audio Loading Error in Listener:', {
                        networkState: audioPlayer.networkState,
                        code: error ? error.code : 'N/A',
                        message: error ? error.message : 'Unknown Error Object',
                        event: e
                    });
                    if (playBtn) {
                        // FIX: Show error state without breaking CSS
                        playBtn.classList.remove('loading');
                        playBtn.disabled = true;
                        playBtn.style.opacity = '0.5';
                    }
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                    alert('Error loading audio. Please check your internet connection or try refreshing the page.');
                }, { once: true });
            }
            
            if (referenceTextDiv) referenceTextDiv.textContent = referenceText;
            if (userInput) userInput.value = '';
            if (liveFeedback) liveFeedback.innerHTML = 'Live Feedback';
            if (statsSection) statsSection.style.display = 'none';
            
            sentenceStartTime = null;
            totalSessionTime = 0;
            hasStartedTyping = false;
            sessionResults = [];
            
            setTimeout(sendHeightToParent, 500);
        }

        function compareTexts(reference, userText) {
            userText = convertGermanChars(userText);
            
            const ignoreCase = ignoreCaseActive;
            const ignorePunctuation = true;
            
            let refNormalized = reference;
            let userNormalized = userText;
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            const result = [];
            let correct = 0;
            let wrongPosition = 0;
            let wrong = 0;
            let extra = 0;
            let missing = 0;
            
            for (let i = 0; i < alignment.length; i++) {
                const item = alignment[i];
                
                if (i > 0) {
                    result.push({ char: ' ', status: 'word-boundary' });
                }
                
                if (item.type === 'match') {
                    for (let char of item.userWord) {
                        result.push({ char, status: 'correct' });
                        correct++;
                    }
                } else if (item.type === 'substitute') {
                    const ref = item.refWord;
                    const user = item.userWord;

                    let missingPrefix = 0;
                    let missingSuffix = 0;

                    for (let idx = 1; idx <= ref.length; idx++) {
                        if (ref.slice(-idx) === user) {
                            missingPrefix = ref.length - idx;
                            break;
                        }
                    }
                    if (missingPrefix === 0) {
                        for (let idx = 1; idx <= ref.length; idx++) {
                            if (ref.slice(0, idx) === user) {
                                missingSuffix = ref.length - idx;
                                break;
                            }
                        }
                    }

                    if (missingPrefix > 0) {
                        for (let k = 0; k < missingPrefix; k++) {
                            if (k > 0) result.push({ char: ' ', status: 'char-space' });
                            result.push({ char: '_', status: 'missing' });
                            missing++;
                        }
                    }

                    for (let c = 0; c < user.length; c++) {
                        result.push({ char: user[c], status: 'wrong' });
                        wrong++;
                    }

                    if (missingSuffix > 0) {
                        for (let k = 0; k < missingSuffix; k++) {
                            result.push({ char: ' ', status: 'char-space' });
                            result.push({ char: '_', status: 'missing' });
                            missing++;
                        }
                    }

                } else if (item.type === 'insert') {
                    for (let char of item.userWord) {
                        result.push({ char, status: 'extra' });
                        extra++;
                    }
                } else if (item.type === 'delete') {
                    const wordLength = item.refWord.length;
                    
                    for (let k = 0; k < wordLength; k++) {
                        if (k > 0) {
                            result.push({ char: ' ', status: 'char-space' });
                        }
                        result.push({ char: '_', status: 'missing' });
                        missing++;
                    }
                }
            }
            
            return {
                chars: result,
                stats: { 
                    correct, 
                    wrongPosition, 
                    wrong, 
                    extra,
                    missing,
                    total: refNormalized.replace(/\s/g, '').length 
                }
            };
        }

        function alignSequencesWithGaps(refWords, userWords) {
            const N = refWords.length, M = userWords.length;
            const dp = Array.from({ length: N + 1 }, () => Array(M + 1).fill(0));

            const COST = { MATCH: 0, SUB: 3, INS: 2, DEL: 2 };

            for (let i = 0; i <= N; i++) dp[i][0] = i * COST.DEL;
            for (let j = 0; j <= M; j++) dp[0][j] = j * COST.INS;

            for (let i = 1; i <= N; i++) {
                for (let j = 1; j <= M; j++) {
                    const matchCost = dp[i - 1][j - 1] +
                        (refWords[i - 1] === userWords[j - 1] ? COST.MATCH : COST.SUB);
                    const delCost = dp[i - 1][j] + COST.DEL;
                    const insCost = dp[i][j - 1] + COST.INS;

                    dp[i][j] = Math.min(matchCost, delCost, insCost);
                }
            }

            let i = N, j = M, alignment = [];
            while (i > 0 || j > 0) {
                const current = dp[i][j];

                if (i > 0 && j > 0 &&
                    current === dp[i - 1][j - 1] +
                               (refWords[i - 1] === userWords[j - 1] ? COST.MATCH : COST.SUB)) {
                    alignment.unshift({
                        type: refWords[i - 1] === userWords[j - 1] ? 'match' : 'substitute',
                        refWord: refWords[i - 1],
                        userWord: userWords[j - 1]
                    });
                    i--; j--;
                    continue;
                }

                if (i > 0 && current === dp[i - 1][j] + COST.DEL) {
                    alignment.unshift({ type: 'delete', refWord: refWords[i - 1], userWord: null });
                    i--;
                    continue;
                }

                alignment.unshift({ type: 'insert', refWord: null, userWord: userWords[j - 1] });
                j--;
            }

            return alignment;
        }

        function updateLiveFeedback() {
            if (!userInput || !liveFeedback) return;
            
            const userText = userInput.value;
            
            if (userText.trim() === '') {
                liveFeedback.innerHTML = 'Live Feedback';
                return;
            }
            
            const comparison = compareTexts(referenceText, userText);
            
            let feedbackHTML = '';
            
            comparison.chars.forEach(item => {
                let char = item.char;
                
                if (char === ' ') {
                    if (item.status === 'word-boundary') {
                        char = '&nbsp;&nbsp;&nbsp;';
                    } else if (item.status === 'char-space') {
                        char = '&nbsp;';
                    } else {
                        char = '&nbsp;';
                    }
                } else if (char === '\n') {
                    char = '<br>';
                }
                
                feedbackHTML += `<span class="char-${item.status}">${char}</span>`;
            });
            
            liveFeedback.innerHTML = feedbackHTML;
        }

        function updateProgress() {
            if (!audioPlayer || !timeDisplay || !progressBar) return;
            
            const currentTime = audioPlayer.currentTime;
            const duration = audioPlayer.duration;
            
            if (duration) {
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
                
                const formatTime = (time) => {
                    const minutes = Math.floor(time / 60);
                    const seconds = Math.floor(time % 60);
                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                };
                
                timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
            }
        }

        function calculateWordStats(comparison) {
            const ignoreCase = ignoreCaseActive;
            const ignorePunctuation = true;
            
            let refNormalized = referenceText;
            let userNormalized = userInput.value;
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            let correctWords = 0;
            let wrongWords = 0;
            let totalWords = refWords.length;
            
            alignment.forEach(item => {
                if (item.type === 'match') {
                    correctWords++;
                } else if (item.type === 'substitute' || item.type === 'delete') {
                    wrongWords++;
                }
            });
            
            return {
                correctWords,
                wrongWords,
                totalWords
            };
        }

        function showFinalResult() {
            if (!userInput) return;
            
            if (userInput.value.trim() && sessionResults.length === currentCueIndex) {
                let sentenceTime = 0;
                if (hasStartedTyping && sentenceStartTime) {
                    sentenceTime = (Date.now() - sentenceStartTime) / 1000;
                    totalSessionTime += sentenceTime;
                }

                const userText = userInput.value;
                const comparison = compareTexts(referenceText, userText);
                const wordStats = calculateWordStats(comparison);
                
                sessionResults.push({
                    sentenceIndex: currentCueIndex,
                    reference: referenceText,
                    userInput: userText,
                    stats: wordStats,
                    time: sentenceTime,
                    comparison: comparison
                });
            }
            
            let totalCorrectWords = 0;
            let totalWrongWords = 0;
            let totalWords = 0;
            
            sessionResults.forEach(result => {
                totalCorrectWords += result.stats.correctWords;
                totalWrongWords += result.stats.wrongWords;
                totalWords += result.stats.totalWords;
            });
            
            const accuracy = totalWords > 0 ? Math.round((totalCorrectWords / totalWords) * 100) : 0;
            
            if (accuracyPercent) accuracyPercent.textContent = accuracy + '%';
            if (correctWords) correctWords.textContent = totalCorrectWords;
            if (wrongWords) wrongWords.textContent = totalWrongWords;

            const timeElement = document.getElementById('timeTaken');
            if (timeElement) {
                timeElement.textContent = formatTime(totalSessionTime);
            }
            
            if (statsSection) statsSection.style.display = 'grid';
                        
            setTimeout(sendHeightToParent, 100);
        }
        
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function showHint() {
            if (!referenceText || !hintBtn) return;
            
            // Remove any existing tooltip
            const existingTooltip = hintBtn.querySelector('.hint-tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }
            
            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.className = 'hint-tooltip';
            tooltip.textContent = referenceText;
            
            // Add tooltip to hint button
            hintBtn.appendChild(tooltip);
            
            // Show tooltip with animation
            setTimeout(() => {
                tooltip.classList.add('show');
            }, 10);
        }

        function hideHint() {
            if (!hintBtn) return;
            
            const tooltip = hintBtn.querySelector('.hint-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
                setTimeout(() => {
                    tooltip.remove();
                }, 200); // Wait for fade out animation
            }
        }

        function showAnswer() {
            if (referenceTextDiv) {
                referenceTextDiv.style.display = 'block';
                setTimeout(() => {
                    referenceTextDiv.style.display = 'none';
                    sendHeightToParent();
                }, 10000);
                sendHeightToParent();
            }
        }
    </script>
</body>
</html>
