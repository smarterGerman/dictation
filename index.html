<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>German Dictation Tool</title>
    <style>
    /* General Body Styles */
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #e0f2fe 0%, #f3e5f5 100%); /* Light blue to light purple */
        color: #333;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start; /* Align content to the top */
        box-sizing: border-box; /* Include padding in element's total width and height */
        transition: background-color 0.3s ease, color 0.3s ease; /* Smooth theme transition */
    }

    /* Dark Theme */
    body.dark-theme {
        background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Dark gradient */
        color: #f7fafc; /* Light text */
    }

    /* Main Container for the entire tool */
    .container {
        background-color: #fff;
        border-radius: 12px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        padding: 30px;
        max-width: 700px;
        width: 100%;
        text-align: center;
        margin-bottom: 20px; /* Space between container and anything below */
        box-sizing: border-box;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }

    body.dark-theme .container {
        background-color: #2d3748;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }

    h1 {
        color: #6a0dad; /* Purple */
        margin-bottom: 25px;
        font-size: 2em;
    }

    body.dark-theme h1 {
        color: #9f7aea; /* Lighter purple for dark theme */
    }

    /* Lesson Title */
    #lessonTitle {
        font-size: 1.4em;
        font-weight: 600;
        margin-top: 0;
        margin-bottom: 15px;
        color: #4a5568;
    }

    body.dark-theme #lessonTitle {
        color: #cbd5e0;
    }

    /* Audio Section */
    .audio-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        margin-bottom: 25px;
        padding: 20px;
        background: linear-gradient(135deg, #e0f2fe 0%, #f3e5f5 100%); /* Same as body for blending */
        border-radius: 10px;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    body.dark-theme .audio-section {
        background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
    }

    .audio-controls {
        display: flex;
        align-items: center;
        gap: 15px;
        width: 100%;
        justify-content: center;
        margin-top: 10px; /* Space above controls */
    }

    .toggle-btn {
        background-color: #8b5cf6; /* Vibrant purple */
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 1.8em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.2s ease, opacity 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        flex-shrink: 0; /* Prevent shrinking */
        line-height: 1; /* Adjust for icon vertical alignment */
        padding: 0; /* Remove default padding */
    }

    .toggle-btn:hover:not(:disabled) {
        background-color: #7c3aed; /* Darker purple on hover */
        transform: translateY(-2px);
    }

    .toggle-btn:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        box-shadow: none;
        opacity: 0.7;
    }

    .toggle-btn.playing {
        background-color: #ef4444; /* Red for pause */
    }

    .toggle-btn.playing:hover:not(:disabled) {
        background-color: #dc2626;
    }

    /* Progress bar container (the track) */
    .progress-container {
        flex-grow: 1; /* Allows it to take up available space in the flex container */
        max-width: 320px; /* Limits its maximum width on large screens */
        height: 8px;
        background: rgba(0, 0, 0, 0.3); /* Darker, more visible background for the track */
        border-radius: 20px;
        overflow: hidden; /* Ensures inner bar doesn't overflow corners */
        margin: 0 10px; /* Add horizontal margin to separate from buttons/time */
        cursor: pointer; /* Indicate it's clickable */
    }

    body.dark-theme .progress-container {
        background: rgba(255, 255, 255, 0.2); /* Lighter background for dark theme */
    }

    /* Progress bar (the filled part) */
    .progress-bar {
        height: 100%;
        width: 0%; /* Initial state */
        background: linear-gradient(90deg, #a855f7, #ec4899); /* Vibrant gradient */
        border-radius: 20px;
        transition: width 0.3s ease; /* Smooth transition for width changes */
    }

    /* Time Display */
    #timeDisplay {
        font-family: 'SF Mono', 'Consolas', monospace; /* Monospaced font for time */
        font-size: 0.9em;
        color: #555;
        min-width: 90px; /* Ensure space for time */
        text-align: center;
    }

    body.dark-theme #timeDisplay {
        color: #a0aec0;
    }

    /* Loading Spinner */
    #loadingSpinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #3498db;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        margin-left: 10px; /* Space from button */
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .hidden {
        display: none !important; /* Forces element to be hidden */
    }

    /* Text Input Area */
    .input-area {
        margin-bottom: 25px;
        width: 100%;
    }

    #currentSentence {
        background-color: #f0f4f8;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        font-size: 1.1em;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: #4a5568;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.08);
    }

    body.dark-theme #currentSentence {
        background-color: #1a202c;
        color: #cbd5e0;
    }

    .input-field {
        width: calc(100% - 20px); /* Account for padding */
        padding: 12px;
        border: 1px solid #ccc;
        border-radius: 8px;
        font-size: 1em;
        box-sizing: border-box;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    .input-field:focus {
        border-color: #8b5cf6;
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2);
        outline: none;
    }

    body.dark-theme .input-field {
        background-color: #4a5568;
        border-color: #616e7f;
        color: #f7fafc;
    }

    .live-feedback {
        margin-top: 15px;
        padding: 10px;
        background-color: #e6ffed; /* Light green */
        border-left: 5px solid #48bb78; /* Green border */
        border-radius: 5px;
        text-align: left;
        font-size: 0.95em;
        line-height: 1.5;
        color: #2d3748;
    }

    body.dark-theme .live-feedback {
        background-color: #2d3748;
        border-color: #48bb78;
        color: #e2e8f0;
    }

    .correct-word {
        color: #48bb78; /* Green */
        font-weight: bold;
    }

    .wrong-word {
        color: #e53e3e; /* Red */
        font-weight: bold;
        text-decoration: underline;
    }

    /* Lesson Selection */
    .lesson-selector {
        margin-bottom: 20px;
    }

    label {
        font-weight: 600;
        margin-right: 10px;
        color: #4a5568;
    }

    body.dark-theme label {
        color: #cbd5e0;
    }

    #lessonSelect {
        padding: 8px 12px;
        border-radius: 5px;
        border: 1px solid #ccc;
        font-size: 1em;
        background-color: #fff;
        cursor: pointer;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    #lessonSelect:focus {
        border-color: #8b5cf6;
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2);
        outline: none;
    }

    body.dark-theme #lessonSelect {
        background-color: #4a5568;
        border-color: #616e7f;
        color: #f7fafc;
    }

    /* Modal Styles */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 100; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        justify-content: center; /* Center content horizontally */
        align-items: center; /* Center content vertically */
    }

    .modal-content {
        background-color: #fefefe;
        margin: auto; /* Auto margin for centering */
        padding: 30px;
        border: 1px solid #888;
        border-radius: 10px;
        width: 80%; /* Could be responsive */
        max-width: 500px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        position: relative; /* For close button positioning */
        text-align: left;
    }

    body.dark-theme .modal-content {
        background-color: #2d3748;
        border-color: #4a5568;
        color: #f7fafc;
    }

    .close-button {
        color: #aaa;
        position: absolute;
        top: 10px;
        right: 20px;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
    }

    .close-button:hover,
    .close-button:focus {
        color: #000;
        text-decoration: none;
        cursor: pointer;
    }

    body.dark-theme .close-button {
        color: #f7fafc;
    }

    body.dark-theme .close-button:hover,
    body.dark-theme .close-button:focus {
        color: #cbd5e0;
    }

    /* Settings specific styles */
    .settings-group {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
    }

    body.dark-theme .settings-group {
        border-color: #4a5568;
    }

    .settings-group:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .settings-group h3 {
        margin-top: 0;
        color: #6a0dad;
        font-size: 1.2em;
        margin-bottom: 15px;
    }

    body.dark-theme .settings-group h3 {
        color: #9f7aea;
    }

    .settings-option {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .settings-option label {
        flex-grow: 1;
        margin-right: 15px;
    }

    .settings-option input[type="checkbox"] {
        transform: scale(1.2); /* Make checkbox slightly larger */
        margin-right: 5px;
    }

    /* Stats Display */
    .stats-summary {
        margin-bottom: 20px;
        text-align: center;
        font-size: 1.1em;
    }

    .stats-summary p {
        margin: 5px 0;
    }

    .mistakes-list {
        list-style: none;
        padding: 0;
        text-align: left;
    }

    .mistakes-list li {
        background-color: #fff5f5;
        border: 1px solid #feb2b2;
        border-radius: 5px;
        padding: 8px 12px;
        margin-bottom: 8px;
    }

    body.dark-theme .mistakes-list li {
        background-color: #4a5568;
        border-color: #feb2b2;
    }

    /* Responsive adjustments */
    @media(max-width:768px){
        body { padding: 10px; }
        .container {
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        h1 { font-size: 1.8em; margin-bottom: 20px; }
        .audio-section{ padding: 15px; gap: 10px; }
        .audio-controls {
            flex-wrap: wrap; /* Allows items to wrap to next line */
            justify-content: center; /* Centers items when they wrap */
            padding: 0 5px; /* Small horizontal padding for controls */
            gap: 10px; /* Adjust gap for wrapped items */
        }
        .toggle-btn { width: 45px; height: 45px; font-size: 1.6em; }

        /* Hide progress bar on mobile */
        .progress-container {
            display: none; /* This hides the progress bar ONLY on screens up to 768px wide */
        }

        #timeDisplay { font-size: 0.85em; min-width: 80px; }
        .input-field, .live-feedback{ padding: 12px; font-size: 0.95em; }
        #currentSentence { font-size: 1em; min-height: 35px; padding: 12px; }
        .modal-content {
            width: 95%; /* Make modal wider on small screens */
            padding: 20px;
        }
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <!-- AUDIO SECTION -->
            <div class="audio-section">
                <div class="audio-controls">
                    <button class="nav-btn" id="prevBtn" title="Previous sentence">‹</button>
                    <button class="play-btn" id="playBtn">
                        <div class="loading-spinner" id="loadingSpinner"></div>
                    </button>
                    <button class="nav-btn" id="nextBtn" title="Next sentence">›</button>
                    <button class="toggle-btn" id="ignoreCaseBtn" title="Ignore Capitalization">Aa</button>
                    <button class="toggle-btn" id="speedBtn" title="Playback Speed">100</button>
                    <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                    <span id="timeDisplay">0:00 / 0:00</span>
                    <button class="toggle-btn" id="hintBtn" title="Show expected sentence">?</button>
                    <button class="toggle-btn" id="endDictationBtn" title="End dictation & show stats">X</button>
                </div>
                <audio id="audioPlayer" preload="auto"></audio>
            </div>

            <!-- TEXT & FEEDBACK -->
            <div class="text-section">
                <div class="input-area">
                    <div class="live-feedback" id="liveFeedback">Live Feedback</div>
                    <textarea class="input-field" id="userInput" placeholder="" autofocus></textarea>
                </div>

                <div class="options">
                    <!-- Options moved to audio controls -->
                </div>

                <div class="reference-text" id="referenceText"></div>
            </div>

            <!-- STATS & CONTROLS -->
            <div class="stats-section">
                <div class="stats" id="statsSection" style="display:none;">
                    <div class="stat-item"><span class="stat-label">Accuracy</span><span class="stat-value" id="accuracyPercent">0%</span></div>
                    <div class="stat-item"><span class="stat-label">Correct Words</span><span class="stat-value" id="correctWords">0</span></div>
                    <div class="stat-item"><span class="stat-label">Wrong Words</span><span class="stat-value" id="wrongWords">0</span></div>
                    <div class="stat-item"><span class="stat-label">Time Taken</span><span class="stat-value" id="timeTaken">0:00</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // Audio Player Elements
    const audioPlayer = document.getElementById('audioPlayer');
    const playBtn = document.getElementById('playBtn');
    const progressBar = document.getElementById('progressBar');
    const loadingSpinner = document.getElementById('loadingSpinner'); // Make sure you have this ID on your spinner element

    // Text Display Elements
    const currentSentenceElement = document.getElementById('currentSentence');
    const liveFeedbackElement = document.getElementById('liveFeedback');
    const sentenceInput = document.getElementById('sentenceInput');
    const timeDisplay = document.getElementById('timeDisplay'); // Added for time display

    // Control Buttons
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const hintBtn = document.getElementById('hintBtn');
    const endDictationBtn = document.getElementById('endDictationBtn');
    const showTranslationBtn = document.getElementById('showTranslationBtn');
    const showOriginalBtn = document.getElementById('showOriginalBtn');
    const speedBtn = document.getElementById('speedBtn'); // Assuming you have a speed button

    // Other elements
    const feedbackModal = document.getElementById('feedbackModal');
    const statsContainer = document.getElementById('statsContainer');
    const dictationArea = document.getElementById('dictationArea');
    const totalWordsSpan = document.getElementById('totalWords');
    const correctWordsSpan = document.getElementById('correctWords');
    const accuracySpan = document.getElementById('accuracy');
    const mistakesContainer = document.getElementById('mistakesContainer');
    const restartBtn = document.getElementById('restartBtn');
    const settingsModal = document.getElementById('settingsModal');
    const openSettingsBtn = document.getElementById('openSettingsBtn');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');
    const dictationModeSelect = document.getElementById('dictationMode');
    const lessonSelect = document.getElementById('lessonSelect');
    const showSourceTextCheckbox = document.getElementById('showSourceText');
    const themeToggle = document.getElementById('themeToggle'); // Assuming you have a theme toggle
    const lessonTitleElement = document.getElementById('lessonTitle');

    // Global Variables
    let currentLessonIndex = 0;
    let lessonData = null;
    let vttCues = [];
    let currentCueIndex = 0;
    let playbackTimeout = null;
    let highlightTimeout = null;
    let feedbackDisplayed = false;
    let dictationActive = false; // To control dictation flow
    let isTranslationVisible = false;
    let isOriginalVisible = false;

    // --- Configuration ---
    const CONFIG = {
        lessonsUrl: 'https://raw.githubusercontent.com/smarterGerman/dictation/main/lessons/lessons.json'
    };

    // --- Utility Functions ---

    function updateProgressBar() {
        if (!audioPlayer || !progressBar || isNaN(audioPlayer.duration) || audioPlayer.duration === 0) {
            progressBar.style.width = '0%';
            if (timeDisplay) timeDisplay.textContent = '0:00 / 0:00';
            return;
        }

        const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
        progressBar.style.width = progress + '%';
        if (timeDisplay) timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(audioPlayer.duration)}`;
    }

    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }

    function updateSentenceDisplay() {
        if (vttCues.length === 0) {
            if (currentSentenceElement) currentSentenceElement.textContent = 'No sentences loaded.';
            return;
        }

        const cue = vttCues[currentCueIndex];
        if (currentSentenceElement) currentSentenceElement.textContent = isOriginalVisible ? cue.text : '...'; // Show original if toggled, otherwise placeholder
        if (sentenceInput) sentenceInput.value = '';
        clearFeedback();
        if (sentenceInput) sentenceInput.focus();

        // Update translation visibility based on user setting
        if (showTranslationBtn) {
            if (isTranslationVisible && cue.translation) {
                showTranslationBtn.textContent = cue.translation;
            } else {
                showTranslationBtn.textContent = 'Aa';
            }
        }
        // Update original visibility based on user setting
        if (showOriginalBtn) {
            showOriginalBtn.textContent = isOriginalVisible ? cue.text : '100';
        }
    }

    function checkAnswer() {
        if (!dictationActive || vttCues.length === 0 || currentCueIndex < 0 || currentCueIndex >= vttCues.length) return;

        const expected = vttCues[currentCueIndex].text;
        const actual = sentenceInput.value;

        const {
            feedbackHtml,
            isCorrect,
            correctCount,
            totalCount
        } = generateFeedback(expected, actual);

        showFeedback(feedbackHtml);

        if (isCorrect) {
            setTimeout(() => {
                nextSentence();
            }, 1000); // Wait a bit before moving to the next sentence
        }
    }

    function generateFeedback(expected, actual) {
        const expectedWords = expected.split(/\s+/);
        const actualWords = actual.split(/\s+/);
        let feedbackHtml = '';
        let correctCount = 0;
        let totalCount = expectedWords.length;

        for (let i = 0; i < expectedWords.length; i++) {
            const expectedWord = expectedWords[i].toLowerCase().replace(/[.,!?;:]/g, '');
            const actualWord = (actualWords[i] || '').toLowerCase().replace(/[.,!?;:]/g, '');

            if (expectedWord === actualWord) {
                feedbackHtml += `<span class="correct-word">${expectedWords[i]}</span> `;
                correctCount++;
            } else {
                feedbackHtml += `<span class="wrong-word">${actualWords[i] || '[_]'}</span> `;
            }
        }

        return {
            feedbackHtml,
            isCorrect: correctCount === totalCount,
            correctCount,
            totalCount
        };
    }

    function showFeedback(htmlContent) {
        if (liveFeedbackElement) {
            liveFeedbackElement.innerHTML = htmlContent;
            liveFeedbackElement.classList.remove('hidden');
            feedbackDisplayed = true;
        }
    }

    function clearFeedback() {
        if (liveFeedbackElement) {
            liveFeedbackElement.innerHTML = '';
            liveFeedbackElement.classList.add('hidden');
            feedbackDisplayed = false;
        }
    }

    function nextSentence() {
        if (currentCueIndex < vttCues.length - 1) {
            currentCueIndex++;
            updateSentenceDisplay();
            playCurrentSentence();
        } else {
            endDictation();
        }
    }

    function previousSentence() {
        if (currentCueIndex > 0) {
            currentCueIndex--;
            updateSentenceDisplay();
            playCurrentSentence();
        }
    }

    function playCurrentSentence() {
        if (vttCues.length === 0 || currentCueIndex < 0 || currentCueIndex >= vttCues.length) {
            console.warn("No sentences or invalid cue index to play.");
            if (playBtn) playBtn.classList.remove('playing');
            return;
        }
        const cue = vttCues[currentCueIndex];
        audioPlayer.currentTime = cue.start;

        // Attempt to play and handle the promise for mobile compatibility
        const playPromise = audioPlayer.play();

        if (playPromise !== undefined) {
            playPromise.then(() => {
                // Playback started successfully
                if (playBtn) playBtn.classList.add('playing');
                startHighlighting();
            }).catch(error => {
                // Playback was prevented (e.g., autoplay policy on mobile)
                console.error("Audio playback prevented or failed:", error);
                if (playBtn) playBtn.classList.remove('playing');
                // Optionally: Provide a more user-friendly message or visual cue
            });
        }
    }

    function pauseAudio() {
        audioPlayer.pause();
        if (playBtn) playBtn.classList.remove('playing');
        stopHighlighting();
        if (playbackTimeout) clearTimeout(playbackTimeout);
    }

    function togglePlayback() {
        if (audioPlayer.paused) {
            // If the audio source isn't set yet or the current lesson isn't loaded
            if (!audioPlayer.src || vttCues.length === 0) {
                // Try to load the current lesson, then play
                loadLesson(currentLessonIndex).then(() => {
                    playCurrentSentence();
                }).catch(error => {
                    console.error("Failed to load lesson for playback:", error);
                    // Handle error loading lesson (e.g., show message)
                });
            } else {
                playCurrentSentence();
            }
        } else {
            pauseAudio();
        }
    }

    function startHighlighting() {
        stopHighlighting(); // Clear any existing timeout
        if (vttCues.length === 0 || currentCueIndex < 0 || currentCueIndex >= vttCues.length) return;

        const cue = vttCues[currentCueIndex];
        // The duration to highlight is until the cue ends
        const durationUntilCueEnd = (cue.end - audioPlayer.currentTime) * 1000;

        highlightTimeout = setTimeout(() => {
            // Logic if needed when cue ends, e.g., auto-pause, or just let next timeupdate handle it.
            // For dictation, typically we let the user interact.
            // You might want to call pauseAudio() here if you want it to stop exactly at cue.end
        }, durationUntilCueEnd);
    }

    function stopHighlighting() {
        if (highlightTimeout) {
            clearTimeout(highlightTimeout);
            highlightTimeout = null;
        }
    }

    function loadLesson(index) {
        dictationActive = false; // Pause dictation flow while loading
        clearFeedback();
        if (sentenceInput) sentenceInput.value = '';
        if (currentSentenceElement) currentSentenceElement.textContent = 'Loading lesson...';
        if (playBtn) {
            playBtn.textContent = '⏳'; // Show hourclock icon
            playBtn.disabled = true;
            playBtn.classList.remove('playing');
        }
        if (loadingSpinner) loadingSpinner.classList.remove('hidden'); // Show spinner

        // Reset progress bar immediately
        if (progressBar) progressBar.style.width = '0%';
        audioPlayer.currentTime = 0; // Reset audio position
        updateProgressBar(); // Update time display as well

        return fetch(CONFIG.lessonsUrl)
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                lessonData = data.lessons[index];
                if (!lessonData) {
                    throw new Error(`Lesson at index ${index} not found.`);
                }
                if (lessonTitleElement) {
                    lessonTitleElement.textContent = lessonData.title; // Update lesson title
                } else {
                    console.warn("Lesson title element not found.");
                }
                audioPlayer.src = lessonData.audioUrl;
                audioPlayer.load(); // Ensure audio element attempts to load

                return fetchVTTFile(lessonData.vttUrl);
            })
            .then(vttText => {
                vttCues = parseVTT(vttText);
                currentCueIndex = 0;
                updateSentenceDisplay();
                dictationActive = true; // Resume dictation flow after loading
                saveState(); // Save current lesson state
            })
            .catch(error => {
                console.error("Failed to load lesson:", error);
                if (currentSentenceElement) currentSentenceElement.textContent = 'Error loading lesson.';
                if (playBtn) {
                    playBtn.textContent = '❌';
                    playBtn.disabled = true;
                }
                if (loadingSpinner) loadingSpinner.classList.add('hidden'); // Hide spinner
            });
    }

    function fetchVTTFile(url) {
        return fetch(url)
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return response.text();
            });
    }

    function parseVTT(vttText) {
        const lines = vttText.split('\n');
        const cues = [];
        let i = 0;

        while (i < lines.length) {
            if (lines[i].trim() === 'WEBVTT') {
                i++; // Skip WEBVTT header
                continue;
            }
            if (lines[i].trim() === '') {
                i++; // Skip empty lines
                continue;
            }

            // Check if it's a cue ID line (optional)
            if (!isNaN(parseInt(lines[i].trim(), 10)) && !lines[i].includes('-->')) {
                i++; // Skip cue ID if present
                continue;
            }

            // Time cue line
            if (lines[i].includes('-->')) {
                const parts = lines[i].split('-->').map(s => s.trim());
                const start = parseVTTTime(parts[0]);
                const end = parseVTTTime(parts[1].split(' ')[0]); // Remove any extra text after time

                i++;
                let text = '';
                let translation = '';
                while (i < lines.length && lines[i].trim() !== '') {
                    const line = lines[i].trim();
                    if (line.startsWith('(') && line.endsWith(')')) { // Check for (translation)
                        translation = line.substring(1, line.length - 1);
                    } else {
                        text += line + ' ';
                    }
                    i++;
                }
                cues.push({
                    start: start,
                    end: end,
                    text: text.trim(),
                    translation: translation.trim()
                });
            } else {
                i++; // Skip lines that don't match expected patterns
            }
        }
        return cues;
    }

    function parseVTTTime(timeString) {
        const parts = timeString.split(':');
        let seconds = 0;
        if (parts.length === 3) {
            seconds = parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
        } else if (parts.length === 2) {
            seconds = parseInt(parts[0]) * 60 + parseFloat(parts[1]);
        }
        return seconds;
    }

    // --- State Management (Save/Load) ---
    function saveState() {
        const state = {
            currentLessonIndex: currentLessonIndex,
            currentCueIndex: currentCueIndex,
            // Add other state variables you want to preserve
        };
        localStorage.setItem('dictationToolState', JSON.stringify(state));
    }

    function loadState() {
        const savedState = localStorage.getItem('dictationToolState');
        if (savedState) {
            const state = JSON.parse(savedState);
            currentLessonIndex = state.currentLessonIndex || 0;
            currentCueIndex = state.currentCueIndex || 0;
        }
    }

    // --- UI/Lesson Management ---
    function populateLessonSelect() {
        if (!lessonSelect) {
            console.warn("Lesson select element not found.");
            return;
        }
        fetch(CONFIG.lessonsUrl)
            .then(response => response.json())
            .then(data => {
                lessonSelect.innerHTML = ''; // Clear existing options
                data.lessons.forEach((lesson, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = lesson.title;
                    lessonSelect.appendChild(option);
                });
                lessonSelect.value = currentLessonIndex; // Set initial selection
            })
            .catch(error => console.error("Failed to load lessons for select:", error));
    }

    function restartLesson() {
        currentCueIndex = 0;
        resetDictation(); // This will clear input/feedback
        updateSentenceDisplay();
        pauseAudio();
        audioPlayer.currentTime = 0;
        updateProgressBar();
        dictationActive = true;
    }

    function resetDictation() {
        if (sentenceInput) sentenceInput.value = '';
        clearFeedback();
        if (sentenceInput) sentenceInput.disabled = false;
    }

    function endDictation() {
        dictationActive = false;
        pauseAudio();
        // You might want to show final stats here or a completion message
        // For example, trigger feedbackModal with final stats
        alert("Dictation ended!"); // Placeholder
    }

    function toggleTranslation() {
        isTranslationVisible = !isTranslationVisible;
        updateSentenceDisplay(); // Re-render to show/hide translation
        // You might want to update button text/class here too
        if (showTranslationBtn) {
            showTranslationBtn.classList.toggle('active', isTranslationVisible);
        }
    }

    function toggleOriginal() {
        isOriginalVisible = !isOriginalVisible;
        updateSentenceDisplay(); // Re-render to show/hide original
        // Update button text/class
        if (showOriginalBtn) {
            showOriginalBtn.classList.toggle('active', isOriginalVisible);
        }
    }

    // Function to navigate to a specific sentence (if you add jump buttons)
    function navigateToSentence(index) {
        if (index >= 0 && index < vttCues.length) {
            currentCueIndex = index;
            updateSentenceDisplay();
            playCurrentSentence();
        }
    }

    // Function to handle settings changes (e.g., dictation mode, show source text)
    function applySettings() {
        // Implement logic for dictationModeSelect, showSourceTextCheckbox, themeToggle
        // For example:
        // const selectedMode = dictationModeSelect.value;
        // const showSource = showSourceTextCheckbox.checked;
        // Update your UI or dictation logic based on these settings.
        // Save settings to localStorage if desired.
    }

    function openSettings() {
        if (settingsModal) settingsModal.classList.remove('hidden');
    }

    function closeSettings() {
        if (settingsModal) settingsModal.classList.add('hidden');
        applySettings(); // Apply settings when modal is closed
    }

    // Function to toggle light/dark theme (basic example)
    function toggleTheme() {
        document.body.classList.toggle('dark-theme');
        // Save theme preference to localStorage
        localStorage.setItem('theme', document.body.classList.contains('dark-theme') ? 'dark' : 'light');
    }

    // Initialize theme based on saved preference
    function initializeTheme() {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-theme');
        }
    }

    // --- Event Listeners ---

    // Audio Player Events
    if (audioPlayer) {
        audioPlayer.ontimeupdate = updateProgressBar;

        audioPlayer.onended = function() {
            if (playBtn) playBtn.classList.remove('playing');
            stopHighlighting();
            // For dictation, we typically want to wait for user input or explicit action.
            // If not dictation mode, could auto-advance: nextSentence();
        };

        audioPlayer.addEventListener('loadedmetadata', () => {
            // This fires once the audio file's metadata is loaded
            if (playBtn) {
                playBtn.textContent = ''; // Remove loading spinner icon
                playBtn.disabled = false; // Enable play button
                playBtn.classList.remove('playing');
            }
            if (loadingSpinner) loadingSpinner.classList.add('hidden'); // Hide spinner
            updateProgressBar(); // Update display with total duration
        }); // Removed { once: true } as metadata can be reloaded

        audioPlayer.addEventListener('error', (e) => {
            console.error('Audio Loading Error:', e);
            if (playBtn) {
                playBtn.textContent = '❌'; // Show error icon
                playBtn.disabled = true; // Keep disabled on error
            }
            if (loadingSpinner) loadingSpinner.classList.add('hidden'); // Hide spinner
            alert('Error loading audio. Please check the audio file path or your internet connection.');
        });
    } else {
        console.error("Audio player element not found!");
    }


    // Control Button Event Listeners
    if (playBtn) playBtn.addEventListener('click', togglePlayback);
    if (prevBtn) prevBtn.addEventListener('click', previousSentence);
    if (nextBtn) nextBtn.addEventListener('click', nextSentence);
    if (hintBtn) hintBtn.addEventListener('click', () => {
        if (vttCues.length > 0 && currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
            showFeedback(vttCues[currentCueIndex].text); // Shows the hint directly
        }
    });
    if (endDictationBtn) endDictationBtn.addEventListener('click', endDictation);
    if (showTranslationBtn) showTranslationBtn.addEventListener('click', toggleTranslation);
    if (showOriginalBtn) showOriginalBtn.addEventListener('click', toggleOriginal);
    if (restartBtn) restartBtn.addEventListener('click', restartLesson);
    if (openSettingsBtn) openSettingsBtn.addEventListener('click', openSettings);
    if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', closeSettings);
    if (themeToggle) themeToggle.addEventListener('click', toggleTheme);
    if (speedBtn) speedBtn.addEventListener('click', () => {
        // Implement speed toggle logic
        if (audioPlayer) {
            audioPlayer.playbackRate = audioPlayer.playbackRate === 1.0 ? 0.75 : 1.0;
            speedBtn.textContent = `${audioPlayer.playbackRate}x`;
        }
    });


    // Input Field Event Listener
    if (sentenceInput) {
        sentenceInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent new line
                checkAnswer();
            }
        });
    }

    // Lesson Selection Event Listener
    if (lessonSelect) {
        lessonSelect.addEventListener('change', (e) => {
            currentLessonIndex = parseInt(e.target.value);
            loadLesson(currentLessonIndex);
        });
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
        initializeTheme(); // Apply saved theme
        loadState(); // Load saved lesson state
        populateLessonSelect(); // Populate lesson dropdown
        loadLesson(currentLessonIndex); // Load the initial lesson
    });
</script>
</body>
</html>
