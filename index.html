<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>German Dictation Tool</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fdfdfd;
            color: #1f2937;
            height: 100%;
            padding: 20px;
            overflow: hidden;
            margin: 0;
        }

        .container {
            max-width: 100%;
            width: 100%;
            height: calc(100% - 40px);
            margin: 0 auto;
            background: transparent;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .content { 
            padding: 0; 
            width: 100%; 
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ----- AUDIO SECTION ---------------------------------------------- */
        .audio-section {
            padding: 20px;
            margin-bottom: 24px;
            border-radius: 20px;
            text-align: center;
            color: #374151;
            width: 100%;
            overflow: visible !important;
            flex-shrink: 0; /* Don't shrink */
        }
        
        .sentence-info { 
            margin-bottom: 24px; 
            font-size: 15px; 
            color: #6b7280; 
            font-weight: 500; 
        }

        /* Unified minimalist design for all screen sizes */
        .audio-controls { 
            display: flex; 
            flex-direction: column;
            align-items: center;
            gap: 16px; 
            margin-bottom: 28px; 
            overflow: visible !important;
        }

        /* Main player pill - dramatically more visible */
        .player-pill {
            background: rgba(255, 255, 255, 0.98); /* Fast opak */
            border: 2px solid rgba(168, 85, 247, 0.4); /* Stärkerer Border */
            border-radius: 50px;
            padding: 16px 32px;
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.25), /* Großer Hauptschatten */
                0 4px 12px rgba(168, 85, 247, 0.3), /* Farbiger Glow */
                inset 0 1px 0 rgba(255, 255, 255, 0.6); /* Innerer Highlight */
            backdrop-filter: blur(10px);
        }

        /* Desktop progress controls - bigger second row */
        .progress-controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px; /* Bigger gap */
            width: 100%;
            max-width: 600px; /* Bigger max-width */
            padding: 0 20px; /* Add padding */
        }

        /* Beautiful gradient-filled buttons without borders */
        .nav-btn,
        .toggle-btn:not(.active):not([class*="speed-"]) {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e1 100%) !important;
            border: none !important;
            color: #475569 !important;
            font-weight: 600 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
        }

        .nav-btn:hover,
        .toggle-btn:not(.active):not([class*="speed-"]):hover {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 50%, #cbd5e1 100%) !important;
            color: #334155 !important;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15) !important;
            transform: translateY(-1px) !important;
        }

        /* Play button and Aa button - pink gradient (when active) */
        .play-btn,
        .toggle-btn.active:not([class*="speed-"]) {
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%) !important;
            color: white !important;
            border: none !important;
            box-shadow: 0 4px 16px rgba(168, 85, 247, 0.3) !important;
        }

        .play-btn:hover,
        .toggle-btn.active:not([class*="speed-"]):hover {
            background: linear-gradient(135deg, #9333ea 0%, #db2777 100%) !important;
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        /* Speed button gradients - traffic light colors */
        .toggle-btn.speed-100 {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%) !important;
            color: white !important;
            border: none !important;
            box-shadow: 0 4px 16px rgba(34, 197, 94, 0.3) !important;
        }

        .toggle-btn.speed-100:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%) !important;
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        .toggle-btn.speed-75 {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
            color: white !important;
            border: none !important;
            box-shadow: 0 4px 16px rgba(251, 191, 36, 0.3) !important;
        }

        .toggle-btn.speed-75:hover {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
            box-shadow: 0 6px 20px rgba(251, 191, 36, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        .toggle-btn.speed-50 {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
            color: white !important;
            border: none !important;
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3) !important;
        }

        .toggle-btn.speed-50:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%) !important;
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        /* Secondary buttons (? and X) - gentle gradient that complements pink */
        .secondary-btn {
            background: linear-gradient(135deg, #fdf2f8 0%, #fce7f3 50%, #f9a8d4 100%) !important;
            border: none !important;
            color: #be185d !important;
            font-weight: 600 !important;
            box-shadow: 0 3px 10px rgba(244, 114, 182, 0.2) !important;
        }

        .secondary-btn:hover {
            background: linear-gradient(135deg, #fce7f3 0%, #f9a8d4 50%, #f472b6 100%) !important;
            color: #a21caf !important;
            box-shadow: 0 4px 12px rgba(244, 114, 182, 0.3) !important;
            transform: translateY(-1px) !important;
        }

        /* Larger desktop buttons */
        .nav-btn,
        .toggle-btn:not(.secondary-btn) {
            width: 56px;
            height: 56px;
            font-size: 18px;
        }

        .play-btn {
            width: 68px;
            height: 68px;
            font-size: 26px;
        }

        /* Secondary button sizing - keep smaller but proportional */
        .secondary-btn {
            width: 40px !important;
            height: 40px !important;
            font-size: 16px !important;
            flex-shrink: 0;
        }

        /* Desktop progress bar */
        .progress-container { 
            flex-grow: 0;
            flex-shrink: 0;
            width: 150px;
            height: 12px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid rgba(168, 85, 247, 0.4);
            border-radius: 20px;
            overflow: hidden;
            margin: 0 8px;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.2),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Desktop player pill */
        .player-pill {
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid rgba(168, 85, 247, 0.4);
            border-radius: 50px;
            padding: 16px 32px;
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 
                0 12px 40px rgba(0, 0, 0, 0.25),
                0 4px 12px rgba(168, 85, 247, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
        }

        /* Time display */
        .progress-controls-row #timeDisplay {
            flex-shrink: 0;
            font-size: 14px;
            color: #6b7280;
            margin: 0;
            min-width: 80px;
            text-align: center;
        }

        .loading-spinner {
            position: absolute;
            width: 64px;
            height: 64px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            display: none;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .play-btn .loading-spinner {
            display: none;
        }

        .play-btn.loading .loading-spinner {
            display: block;
        }

        .play-btn::before { 
            content:''; 
            position:absolute; 
            left:50%; 
            top:50%; 
            transform:translate(-50%,-50%);
            z-index: 2;
        }

        .nav-btn,
        .play-btn,
        .toggle-btn { 
            border: none; 
            border-radius: 50%; 
            cursor: pointer; 
            transition: all .3s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            outline: none;
            position: relative;
        }

        .nav-btn,
        .toggle-btn {
            width: 52px; 
            height: 52px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            font-size: 18px;
            color: #6b7280;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .nav-btn:hover:not(:disabled),
        .toggle-btn:hover { 
            transform: translateY(-2px); 
            background: rgba(255, 255, 255, 1);
            color: #374151;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }
        
        .nav-btn:disabled { 
            opacity:0.3; 
            cursor:not-allowed; 
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(168, 85, 247, 0.3), 0 0 0 3px rgba(168, 85, 247, 0.4), 0 0 20px rgba(168, 85, 247, 0.6);
            transform: translateY(-1px);
        }

        .toggle-btn.active:hover {
            background: linear-gradient(135deg, #9333ea 0%, #db2777 100%);
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.4), 0 0 0 3px rgba(168, 85, 247, 0.5), 0 0 25px rgba(168, 85, 247, 0.7);
            transform: translateY(-2px);
        }

        /* Speed button colors - Traffic Light */
        .toggle-btn.speed-100 {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(34, 197, 94, 0.3);
        }

        .toggle-btn.speed-100:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            box-shadow: 0 8px 24px rgba(34, 197, 94, 0.4);
        }

        .toggle-btn.speed-75 {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(251, 191, 36, 0.3);
        }

        .toggle-btn.speed-75:hover {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 8px 24px rgba(251, 191, 36, 0.4);
        }

        .toggle-btn.speed-50 {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
        }

        .toggle-btn.speed-50:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            box-shadow: 0 8px 24px rgba(239, 68, 68, 0.4);
        }

        /* Text section - flexible but controlled */
        .text-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* Important for flex child */
        }

        /* Hint display area - normal dynamic sizing */
        .hint-display {
            margin: 20px 0;
            padding: 16px 20px;
            background: linear-gradient(135deg, #fef7ff 0%, #f0f9ff 100%);
            border: 2px solid #e879f9;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(232, 121, 249, 0.1);
            flex-shrink: 0;
            transition: all 0.3s ease; /* Smooth transitions */
        }

        .hint-content {
            font-size: 18px;
            color: #374151;
            font-weight: 500;
            line-height: 1.5;
        }

        /* Mobile responsive hint */
        @media(max-width: 768px) {
            .hint-display {
                margin: 15px 0;
                padding: 12px 16px;
            }
            
            .hint-content {
                font-size: 16px;
                line-height: 1.4;
            }
        }

        @keyframes hintSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Remove old tooltip styles */
        /* Remove old tooltip styles */

        .play-btn {
            position: relative;
            width: 72px; 
            height: 72px;
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.3);
            font-size: 28px;
            color: white;
        }
        
        .play-btn:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 12px 32px rgba(168, 85, 247, 0.4);
        }
        
        .play-btn:disabled{
            opacity:.5;
            cursor:not-allowed;
        }
        
        .play-btn::before { 
            content:''; 
            position:absolute; 
            left:50%; 
            top:50%; 
            transform:translate(-50%,-50%); 
        }
        
        .play-btn.playing::before { 
            width:4px;
            height:20px;
            background:white;
            box-shadow:8px 0 0 white; 
        }
        
        .play-btn:not(.playing)::before { 
            border-left:12px solid white; 
            border-top:8px solid transparent; 
            border-bottom:8px solid transparent; 
        }

        #timeDisplay { 
            min-width:110px; 
            font-size:16px; 
            color:#6b7280; 
            font-weight:500; 
            margin-left: 8px; 
            margin-right: 8px;
        }
        
        /* Clean progress bar styling - dramatically more visible */
        .progress-container { 
            flex-grow: 0;
            flex-shrink: 0;
            width: 150px;
            height: 12px; /* Dicker */
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid rgba(168, 85, 247, 0.4);
            border-radius: 20px;
            overflow: hidden;
            margin: 0 8px;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.2),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .progress-bar { 
            height:100%; 
            width:0%; 
            background:linear-gradient(90deg, #a855f7, #ec4899); 
            border-radius:20px; 
            transition:width .3s ease;
        }

        /* ----- INPUT / FEEDBACK ------------------------------------------- */
        .input-area { 
            display:flex; 
            flex-direction:column; 
            gap:20px; 
            padding: 0; 
        }
        
        .input-field {
            width:100%; 
            min-height:100px; 
            padding:18px;
            background: linear-gradient(135deg, #fef7ff 0%, #f0f9ff 100%); 
            color:#374151;
            border:2px solid #e879f9; 
            border-radius: 16px;
            font-size:32px;
            line-height:1.4;
            resize:vertical;
            transition:all .3s ease;
            box-shadow: 0 4px 16px rgba(232, 121, 249, 0.1);
        }
        
        .input-field:focus { 
            border-color:#c084fc; 
            box-shadow:0 0 0 4px rgba(192, 132, 252, 0.15), 0 4px 16px rgba(232, 121, 249, 0.2); 
            outline:none; 
            transform: translateY(-1px);
        }

        .input-field::placeholder {
            font-size: 32px !important; /* Much larger to fill the box */
            color: #9CA3AF;
            opacity: 1;
            line-height: 1.2; /* Tighter line height for better fill */
            transition: color 0.3s ease;
        }
        
        .live-feedback {
            min-height:70px;
            padding:18px;
            background: linear-gradient(135deg, #ecfdf5 0%, #fef3ff 100%); 
            border: none; 
            border-radius: 16px;
            font-size:56px;
            line-height:1.3;
            white-space:pre-wrap; 
            word-break:break-word;
            color: #9ca3af;
            box-shadow: 0 4px 16px rgba(167, 139, 250, 0.1);
        }

        /* feedback colors */
        .char-correct{color:#059669;font-weight:500;} 
        .char-wrong-position{color:#d97706;font-weight:500;} 
        .char-wrong{color:#dc2626;text-decoration:underline;font-weight:500;} 
        .char-missing{color:#d97706;font-style:italic;font-weight:500;} 
        .char-extra{color:#2563eb;font-weight:500;} 
        .char-word-boundary,.char-char-space{color:#9ca3af;}

        /* ----- OPTIONS ----------------------------------------------------- */
        .options { 
            display: none;
        }

        /* ----- STATS & CONTROLS ------------------------------------------- */
        .stats-section {
            margin: 32px 0 0 0;
            padding-top: 24px;
            border-top: 1px solid #f3f4f6;
            flex-shrink: 0; /* Don't shrink */
            max-height: 50vh; /* Limit height */
            overflow-y: auto; /* Allow internal scrolling */
        }

        /* Remove old export controls */
        .export-controls {
            display: none; /* Hide old export controls */
        }
        
        .stats{
            display:grid;
            grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
            gap:16px;
            margin-bottom:24px;
        }

        /* Stats container with export button */
        .stats-with-export {
            display: flex;
            align-items: flex-start;
            gap: 24px;
            margin-bottom: 24px;
        }

        /* Stats container with buttons on the right */
        .stats-with-export {
            display: flex;
            align-items: flex-start;
            gap: 24px;
            margin-bottom: 24px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            flex: 1;
        }

        .export-button-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            flex-shrink: 0;
        }

        /* Player-style round buttons */
        .export-csv-btn, .restart-btn {
            width: 64px;
            height: 64px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all .3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
            font-weight: 600;
        }

        .export-csv-btn {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            font-size: 12px;
            box-shadow: 0 4px 16px rgba(34, 197, 94, 0.3);
        }

        .export-csv-btn:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
            transform: translateY(-1px);
        }

        .restart-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            font-size: 20px;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3);
        }

        .restart-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
            transform: translateY(-1px);
        }
        
        .stat-item{
            background: rgba(255, 255, 255, 0.95); /* More opaque */
            backdrop-filter: blur(10px);
            border: 2px solid rgba(168, 85, 247, 0.2); /* Add visible border */
            border-radius:16px;
            padding:24px;
            text-align:center;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12); /* Stronger shadow */
            transition: all .3s ease;
        }
        
        .stat-item:hover{
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18); /* Even stronger on hover */
            border-color: rgba(168, 85, 247, 0.4); /* More visible border on hover */
        }
        
        .stat-value{
            font-size:36px;
            font-weight:700;
            color:#e879f9;
            margin-bottom:8px;
            display:block;
        }
        
        .stat-label{
            font-size:14px;
            font-weight:500;
            color:#6b7280;
        }

        .reference-text{
            margin-top:24px;
            padding:20px;
            background:#fef9e7;
            border:1px solid #fcd34d;
            border-radius:8px;
            color:#92400e;
            display:none;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        /* Sentence results styling - more compact */
        .sentence-results {
            margin-top: 32px;
            padding: 24px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .sentences-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .sentence-result {
            font-size: 18px;
            line-height: 1.6;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        /* Word coloring in results */
        .result-word-correct {
            color: #059669;
            font-weight: 500;
        }

        .result-word-wrong {
            color: #dc2626;
            font-weight: 500;
            text-decoration: underline;
            cursor: pointer;
            position: relative;
        }

        .result-word-wrong:hover {
            background: rgba(220, 38, 38, 0.1);
            border-radius: 4px;
            padding: 2px 4px;
            margin: -2px -4px;
        }

        .result-word-missing {
            color: #d97706;
            font-style: italic;
            border-bottom: 2px dashed #d97706;
            display: inline-block;
            min-width: 1em;
            cursor: pointer;
            position: relative;
        }

        .result-word-missing:hover {
            background: rgba(217, 119, 6, 0.1);
            border-radius: 4px;
            padding: 2px 4px;
            margin: -2px -4px;
        }

        .result-word-extra {
            color: #2563eb;
            font-weight: 500;
            background: rgba(37, 99, 235, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
        }

        /* Tooltip for wrong words */
        .word-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .word-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #1f2937;
        }

        .word-tooltip.show {
            opacity: 1;
            pointer-events: auto;
        }

        /* Prevent tooltip cutoff */
        .word-tooltip.adjust-left {
            left: 0;
            transform: translateX(0);
        }

        .word-tooltip.adjust-right {
            left: auto;
            right: 0;
            transform: translateX(0);
        }

        .word-tooltip.adjust-left::after {
            left: 20px;
        }

        .word-tooltip.adjust-right::after {
            left: auto;
            right: 20px;
        }

        /* Export controls styling */
        .export-controls {
            text-align: center;
            margin: 24px 0;
            padding: 16px;
        }

        .export-csv-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }

        .export-csv-btn:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.3);
        }

       /* ----- RESPONSIVE -------------------------------------------------- */
       @media(max-width:768px){
    body { padding: 10px; }
    .audio-section{ padding: 15px; }
    
    /* Mobile placeholder text sizing - fill the mobile input box */
    .input-field::placeholder {
        font-size: 20px !important; /* Much larger than 12px to fill mobile box */
        line-height: 1.2; /* Tighter for better vertical fill */
    }

    .input-field, .live-feedback{ padding: 15px; font-size: 24px; }

    /* Mobile: apply same dramatic styling to pill */
    .player-pill {
        padding: 10px 20px;
        gap: 14px;
        background: rgba(255, 255, 255, 0.98); /* Same as desktop */
        border: 2px solid rgba(168, 85, 247, 0.4); /* Same as desktop */
        box-shadow: 
            0 12px 40px rgba(0, 0, 0, 0.25), /* Same dramatic shadow */
            0 4px 12px rgba(168, 85, 247, 0.3), /* Same glow */
            inset 0 1px 0 rgba(255, 255, 255, 0.6); /* Same highlight */
    }

    /* Mobile: apply same styling to progress bar */
    .progress-container {
        width: 120px; /* Slightly smaller for mobile space */
        height: 12px; /* Keep thick */
        background: rgba(255, 255, 255, 0.95); /* Same as desktop */
        border: 2px solid rgba(168, 85, 247, 0.4); /* Same as desktop */
        box-shadow: 
            0 4px 16px rgba(0, 0, 0, 0.2), /* Same shadow */
            inset 0 2px 4px rgba(0, 0, 0, 0.1); /* Same inset */
    }

    .progress-controls-row {
        max-width: 320px;
        gap: 8px;
    }

    /* Smaller buttons on mobile */
    .nav-btn, .toggle-btn {
        width: 48px !important;
        height: 48px !important;
        font-size: 16px !important;
    }

    .play-btn {
        width: 56px !important;
        height: 56px !important;
        font-size: 24px !important;
    }

    .secondary-btn {
        width: 32px !important;
        height: 32px !important;
        font-size: 12px !important;
    }

    .progress-controls-row #timeDisplay {
        font-size: 12px;
        min-width: 70px;
    }
}

        /* Add this new style for your 'X' button */
    .toggle-btn.end-button {
        background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        color: white;
        font-size: 1.5em;
        font-weight: bold;
        line-height: 1;
        padding: 8px 12px;
    }

    .toggle-btn.end-button:hover {
        background: linear-gradient(135deg, #DC2626 0%, #B91C1C 100%);
        transform: translateY(-2px);
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <!-- AUDIO SECTION -->
            <div class="audio-section">
                <div class="audio-controls">
                    <!-- Unified pill design for all screen sizes -->
                    <div class="player-pill">
                        <button class="nav-btn" id="prevBtn" title="Previous sentence">‹</button>
                        <button class="play-btn" id="playBtn">
                            <div class="loading-spinner" id="loadingSpinner"></div>
                        </button>
                        <button class="nav-btn" id="nextBtn" title="Next sentence">›</button>
                        <button class="toggle-btn" id="ignoreCaseBtn" title="Capitalization checking OFF">Aa</button>
                        <button class="toggle-btn" id="speedBtn" title="Playback Speed">100</button>
                    </div>
                    
                    <!-- Progress bar and controls row -->
                    <div class="progress-controls-row">
                        <button class="toggle-btn secondary-btn" id="hintBtn" title="Show expected sentence">?</button>
                        <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                        <span id="timeDisplay">0:00 / 0:00</span>
                        <button class="toggle-btn secondary-btn" id="endDictationBtn" title="End dictation & show stats">X</button>
                    </div>
                </div>
                <audio id="audioPlayer" preload="auto"></audio>
            </div>

            <!-- TEXT & FEEDBACK -->
            <div class="text-section">
                <!-- Hint display area - only appears when needed -->
                <div class="hint-display" id="hintDisplay" style="display: none;">
                    <div class="hint-content" id="hintContent"></div>
                </div>
                
                <div class="input-area">
                    <div class="live-feedback" id="liveFeedback">Live Feedback</div>
                    <textarea class="input-field" id="userInput" placeholder="" autofocus></textarea>
                </div>

                <div class="options">
                    <!-- Options moved to audio controls -->
                </div>

                <div class="reference-text" id="referenceText"></div>
            </div>

            <!-- STATS & CONTROLS -->
            <div class="stats-section">
                <div class="stats-with-export" id="statsSection" style="display:none;">
                    <div class="stats">
                        <div class="stat-item"><span class="stat-label">Accuracy</span><span class="stat-value" id="accuracyPercent">0%</span></div>
                        <div class="stat-item"><span class="stat-label">Correct Words</span><span class="stat-value" id="correctWords">0</span></div>
                        <div class="stat-item"><span class="stat-label">Wrong Words</span><span class="stat-value" id="wrongWords">0</span></div>
                        <div class="stat-item"><span class="stat-label">Time Taken</span><span class="stat-value" id="timeTaken">0:00</span></div>
                    </div>
                    <div class="export-button-container">
                        <button class="restart-btn" id="restartBtn" title="Restart dictation">
                            ↻
                        </button>
                        <button class="export-csv-btn" id="exportCsvBtn" title="Export results as CSV file">
                            CSV
                        </button>
                    </div>
                </div>

                <!-- Export controls - hidden now -->
                <div class="export-controls" id="exportControls" style="display:none;">
                    <button class="export-csv-btn-old" id="exportCsvBtnOld" title="Export results as CSV file">
                        Export CSV
                    </button>
                </div>

                <!-- Detailed sentence results -->
                <div class="sentence-results" id="sentenceResults" style="display:none;">
                    <div class="sentences-container" id="sentencesContainer">
                        <!-- Sentences will be inserted here by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // MODERN AUTO-RESIZE SYSTEM: ResizeObserver + Fallback
        let lastReportedHeight = 0;
        let resizeTimeout = null;

        function sendHeightToParent() {
            // Clear any pending resize calls
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            
            // Use a small delay to ensure DOM is fully updated
            resizeTimeout = setTimeout(() => {
                const height = Math.max(
                    document.body.scrollHeight,
                    document.body.offsetHeight,
                    document.documentElement.scrollHeight,
                    document.documentElement.offsetHeight,
                    document.documentElement.clientHeight
                );
                
                // Only send if height actually changed (prevent spam)
                if (height !== lastReportedHeight) {
                    lastReportedHeight = height;
                    if (window.parent !== window) {
                        window.parent.postMessage({ frameHeight: height }, '*');
                    }
                    console.log('Sent new height:', height);
                }
            }, 50);
        }

        function initializeAutoResize() {
            // Method 1: Modern ResizeObserver (preferred)
            if (window.ResizeObserver) {
                console.log('Using ResizeObserver (modern)');
                
                const resizeObserver = new ResizeObserver(entries => {
                    sendHeightToParent();
                });
                
                // Observe the main container for size changes
                const container = document.querySelector('.container');
                if (container) {
                    resizeObserver.observe(container);
                }
                
                // Also observe document body for additional safety
                resizeObserver.observe(document.body);
                
            } else {
                console.log('Using MutationObserver fallback (older browsers)');
                
                // Method 2: Fallback for older browsers
                const mutationObserver = new MutationObserver(() => {
                    sendHeightToParent();
                });
                
                // Watch for DOM changes that could affect height
                mutationObserver.observe(document.body, {
                    childList: true,      // Child elements added/removed
                    subtree: true,        // Watch all descendants
                    attributes: true,     // Attribute changes (style, class, etc.)
                    attributeFilter: ['style', 'class'], // Only watch relevant attributes
                });
                
                // Additional fallback: Window resize events
                window.addEventListener('resize', sendHeightToParent);
                
                // Backup polling for edge cases (very conservative)
                setInterval(() => {
                    sendHeightToParent();
                }, 5000); // Only every 5 seconds as last resort
            }
            
            // Initial height calculation
            sendHeightToParent();
        }

        window.addEventListener('load', sendHeightToParent);
        window.addEventListener('resize', sendHeightToParent);

        let referenceText = '';
        let isPlaying = false;
        let vttCues = [];
        let currentCueIndex = 0;
        let allLessons = {};
        let currentLessonId = '';
        let hasStartedTyping = false;
        let sentenceStartTime = null;
        let totalSessionTime = 0;
        let sessionResults = [];
        let ignoreCaseActive = true;
        let currentSpeed = 1.0;

        const initialPlaceholderText = "Shift+Cmd+Enter = Play/Pause\nae = ä | oe = ö | ue = ü | B = ß\nType here...";

        const CONFIG = {
            lessonsUrl: 'https://raw.githubusercontent.com/smarterGerman/dictation/main/lessons/lessons.json'
        };

        let audioPlayer, playBtn, progressBar, timeDisplay, referenceTextDiv, loadingSpinner, statsSection;
        let userInput, liveFeedback, accuracyPercent, correctWords, wrongWords;
        let endDictationBtn, resetBtn, ignoreCaseBtn, hintBtn, speedBtn;
        let prevBtn, nextBtn, sentenceInfo, exportCsvBtn;

        window.addEventListener('load', function() {
            audioPlayer = document.getElementById('audioPlayer');
            playBtn = document.getElementById('playBtn');
            progressBar = document.getElementById('progressBar');
            timeDisplay = document.getElementById('timeDisplay');
            referenceTextDiv = document.getElementById('referenceText');
            loadingSpinner = document.getElementById('loadingSpinner');
            statsSection = document.getElementById('statsSection');
            userInput = document.getElementById('userInput');
            
            if (userInput) {
                userInput.placeholder = initialPlaceholderText;
            }
            liveFeedback = document.getElementById('liveFeedback');
            accuracyPercent = document.getElementById('accuracyPercent');
            correctWords = document.getElementById('correctWords');
            wrongWords = document.getElementById('wrongWords');
            endDictationBtn = document.getElementById('endDictationBtn');
            ignoreCaseBtn = document.getElementById('ignoreCaseBtn');
            speedBtn = document.getElementById('speedBtn');
            hintBtn = document.getElementById('hintBtn');
            prevBtn = document.getElementById('prevBtn');
            nextBtn = document.getElementById('nextBtn');
            sentenceInfo = document.getElementById('sentenceInfo');
            exportCsvBtn = document.getElementById('exportCsvBtn');

            if (playBtn) playBtn.addEventListener('click', togglePlayback);
            if (prevBtn) prevBtn.addEventListener('click', goToPreviousSentence);
            if (nextBtn) nextBtn.addEventListener('click', goToNextSentence);
            if (userInput) {
                userInput.addEventListener('input', handleUserInput);
                userInput.addEventListener('keydown', handleKeyDown);
            }
            if (endDictationBtn) endDictationBtn.addEventListener('click', showFinalResult);
            if (ignoreCaseBtn) {
                ignoreCaseBtn.addEventListener('click', toggleIgnoreCase);
                ignoreCaseBtn.classList.remove('active');
                ignoreCaseBtn.title = "Capitalization checking OFF";
            }
            if (speedBtn) {
                speedBtn.addEventListener('click', toggleSpeed);
                speedBtn.classList.add('speed-100');
            }
            if (hintBtn) {
                hintBtn.addEventListener('click', showHint);
            }
            if (exportCsvBtn) {
                exportCsvBtn.addEventListener('click', exportCSV);
            }

            if (audioPlayer) {
                audioPlayer.addEventListener('play', () => {
                    isPlaying = true;
                    if (playBtn) {
                        playBtn.classList.add('playing');
                    }
                    if (userInput) {
                        userInput.focus();
                    }
                });
                audioPlayer.addEventListener('pause', () => {
                    isPlaying = false;
                    if (playBtn) {
                        playBtn.classList.remove('playing');
                    }
                });
                audioPlayer.addEventListener('timeupdate', handleTimeUpdate);
            }

            window.addEventListener('keydown', handleGlobalKeyDown);
            const lessonId = getLessonIdFromUrl() || 'A1L01';
            loadAllLessons().then(() => {
                loadLesson(lessonId);
            });
            window.focus();
            console.log('Main window load event completed, focus attempted.');
            
            // Initialize the modern auto-resize system
            initializeAutoResize();
        });

        function toggleSpeed() {
            if (speedBtn) {
                speedBtn.classList.remove('speed-100', 'speed-75', 'speed-50');
            }
            
            if (currentSpeed === 1.0) {
                currentSpeed = 0.75;
                speedBtn.textContent = '75';
                speedBtn.classList.add('speed-75');
            } else if (currentSpeed === 0.75) {
                currentSpeed = 0.5;
                speedBtn.textContent = '50';
                speedBtn.classList.add('speed-50');
            } else {
                currentSpeed = 1.0;
                speedBtn.textContent = '100';
                speedBtn.classList.add('speed-100');
            }
            
            if (audioPlayer) {
                audioPlayer.playbackRate = currentSpeed;
            }
        }

        function toggleIgnoreCase() {
            ignoreCaseActive = !ignoreCaseActive;
            if (ignoreCaseBtn) {
                if (ignoreCaseActive) {
                    ignoreCaseBtn.classList.remove('active');
                    ignoreCaseBtn.title = "Capitalization checking OFF";
                } else {
                    ignoreCaseBtn.classList.add('active');
                    ignoreCaseBtn.title = "Capitalization checking ON";
                }
            }
            updateLiveFeedback();
        }

        function handleUserInput(e) {
            hideHint();
            
            if (!hasStartedTyping && e.target.value.trim().length > 0) {
                hasStartedTyping = true;
                sentenceStartTime = Date.now();
            }
            
            const cursorPos = e.target.selectionStart;
            const convertedText = convertGermanChars(e.target.value);
            if (convertedText !== e.target.value) {
                e.target.value = convertedText;
                e.target.setSelectionRange(cursorPos, cursorPos);
            }
            updateLiveFeedback();
            setTimeout(sendHeightToParent, 100);
        }

        function handleGlobalKeyDown(e) {
            console.log('Global keydown detected:', e.key, 'Shift:', e.shiftKey, 'Ctrl/Cmd:', (e.ctrlKey || e.metaKey));

            // Hint shortcut: Shift + Ctrl/Cmd + ß (German), / (US), , (French)
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === 'ß') {
                e.preventDefault();
                showHint();
                if (hintBtn) hintBtn.focus();
                return;
            }
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === '/') {
                e.preventDefault();
                showHint();
                if (hintBtn) hintBtn.focus();
                return;
            }
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === ',') {
                e.preventDefault();
                showHint();
                if (hintBtn) hintBtn.focus();
                return;
            }

            // Play/Pause (start dictation): Shift + Ctrl/Cmd + Enter
            if (e.shiftKey && (e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                console.log('Shortcut for togglePlayback activated.');
                togglePlayback();
                return;
            }

            // Sentence navigation: Shift + Ctrl/Cmd + Arrow keys
            if (e.shiftKey && (e.ctrlKey || e.metaKey)) {
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        goToPreviousSentence();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        goToNextSentence();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        playCurrentSentence();
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        toggleSpeed();
                        break;
                }
            }
        }

        function handleKeyDown(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                processCurrentSentenceAndAdvance();
            }
        }

        function processCurrentSentenceAndAdvance() {
            if (!userInput.value.trim()) {
                playCurrentSentence();
                return;
            }

            let sentenceTime = 0;
            if (hasStartedTyping && sentenceStartTime) {
                sentenceTime = (Date.now() - sentenceStartTime) / 1000;
                totalSessionTime += sentenceTime;
            }

            const userText = userInput.value;
            const comparison = compareTexts(referenceText, userText);
            const wordStats = calculateWordStats(comparison);
            
            sessionResults.push({
                sentenceIndex: currentCueIndex,
                reference: referenceText,
                userInput: userText,
                stats: wordStats,
                time: sentenceTime,
                comparison: comparison
            });

            if (currentCueIndex < vttCues.length - 1) {
                goToNextSentence();
                playCurrentSentence();
            } else {
                showFinalResult();
            }
        }

        function getLessonIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('lesson');
        }

        async function loadAllLessons() {
            try {
                const response = await fetch(CONFIG.lessonsUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load lessons: ${response.status}`);
                }
                allLessons = await response.json();
            } catch (error) {
                console.error('Failed to load lessons:', error);
                if (lessonInfo) lessonInfo.textContent = 'Failed to load lessons data';
            }
        }

        function parseVTT(vttText) {
            const lines = vttText.split('\n');
            const cues = [];
            let i = 0;

            while (i < lines.length && !lines[i].includes('-->')) {
                i++;
            }

            while (i < lines.length) {
                const line = lines[i].trim();
                
                if (line.includes('-->')) {
                    const [startTime, endTime] = line.split('-->').map(t => t.trim());
                    const startSeconds = parseTimeToSeconds(startTime);
                    const endSeconds = parseTimeToSeconds(endTime);
                    
                    i++;
                    let text = '';
                    while (i < lines.length && lines[i].trim() !== '') {
                        if (text) text += ' ';
                        text += lines[i].trim();
                        i++;
                    }
                    
                    if (text) {
                        cues.push({
                            start: startSeconds,
                            end: endSeconds,
                            text: text
                        });
                    }
                }
                i++;
            }
            
            return cues;
        }

        function parseTimeToSeconds(timeStr) {
            const parts = timeStr.split(':');
            const seconds = parts[parts.length - 1].split('.');
            const sec = parseInt(seconds[0]);
            const ms = parseInt(seconds[1] || 0);
            
            if (parts.length === 3) {
                const hours = parseInt(parts[0]);
                const minutes = parseInt(parts[1]);
                return hours * 3600 + minutes * 60 + sec + ms / 1000;
            } else {
                const minutes = parseInt(parts[0]);
                return minutes * 60 + sec + ms / 1000;
            }
        }

        async function loadVTTFromUrl(vttUrl) {
            try {
                const response = await fetch(vttUrl);
                if (!response.ok) {
                    throw new Error(`VTT file not found: ${response.status}`);
                }
                
                const vttText = await response.text();
                const cues = parseVTT(vttText);
                return cues;
            } catch (error) {
                console.error('Failed to load VTT file:', error);
                return [];
            }
        }

        function convertGermanChars(text) {
            return text
                .replace(/ae/g, 'ä')
                .replace(/oe/g, 'ö')
                .replace(/ue/g, 'ü')
                .replace(/Ae/g, 'Ä')
                .replace(/Oe/g, 'Ö')
                .replace(/Ue/g, 'Ü')
                .replace(/\B([aeiouäöü])B/g, '$1ß')
                .replace(/([aeiouäöü])B([aeiouäöü])/g, '$1ß$2')
                .replace(/([aeiouäöü])B$/g, '$1ß')
                .replace(/([aeiouäöü])B(\s)/g, '$1ß$2');
        }
        
        function togglePlayback() {
           console.log(`[DEBUG] Play/Pause button tapped. IsPaused: ${audioPlayer.paused}. Current Network State: ${audioPlayer.networkState}.`);
            console.log('togglePlayback called.');
            if (vttCues.length === 0) {
                if (isPlaying) {
                    audioPlayer.pause();
                } else {
                    audioPlayer.play().catch(error => {
                        console.log('Audio playback failed:', error);
                        alert('Audio could not be played. Please check your internet connection.');
                    });
                }
            } else {
                if (isPlaying) {
                    audioPlayer.pause();
                } else {
                    playCurrentSentence();
                }
            }
        }

        function playCurrentSentence() {
            if (currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
                const cue = vttCues[currentCueIndex];
                audioPlayer.currentTime = cue.start;
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('[DEBUG] Playback promise resolved (audio started).');
                    }).catch(error => {
                        console.error('Audio Playback Promise Rejected:', {
                            name: error.name,
                            message: error.message,
                            networkState: audioPlayer.networkState,
                            errorObject: error
                        });
                        alert('Audio could not be played. Please check your internet connection.');
                    });
                }
            }
        }

        function goToPreviousSentence() {
            if (currentCueIndex > 0) {
                currentCueIndex--;
                updateCurrentSentence();
                if (vttCues[currentCueIndex]) {
                    audioPlayer.currentTime = vttCues[currentCueIndex].start;
                }
            }
        }

        function goToNextSentence() {
            if (currentCueIndex < vttCues.length - 1) {
                currentCueIndex++;
                updateCurrentSentence();
                if (vttCues[currentCueIndex]) {
                    audioPlayer.currentTime = vttCues[currentCueIndex].start;
                }
            }
        }

        function updateCurrentSentence() {
            updateNavigationButtons();
            updateSentenceInfo();
            updateCurrentReferenceText();
            
            hideHint();
            
            if (userInput) userInput.value = '';
            if (userInput) {
                if (currentCueIndex < 2) {
                    userInput.placeholder = initialPlaceholderText;
                } else {
                    userInput.placeholder = "Type what you hear here...";
                }
            }
            updateLiveFeedback();
            
            sentenceStartTime = null;
            hasStartedTyping = false;
            
            if (statsSection) statsSection.style.display = 'none';
            
            setTimeout(sendHeightToParent, 100);
        }

        function updateNavigationButtons() {
            if (prevBtn) prevBtn.disabled = (currentCueIndex <= 0);
            if (nextBtn) nextBtn.disabled = (currentCueIndex >= vttCues.length - 1);
        }

        function updateSentenceInfo() {
            if (sentenceInfo && vttCues.length > 0) {
                sentenceInfo.textContent = `Sentence ${currentCueIndex + 1} of ${vttCues.length}`;
            }
        }

        function updateCurrentReferenceText() {
            if (vttCues.length > 0 && currentCueIndex >= 0 && currentCueIndex < vttCues.length) {
                referenceText = vttCues[currentCueIndex].text;
                if (referenceTextDiv) referenceTextDiv.textContent = referenceText;
            }
        }

        function handleTimeUpdate() {
            updateProgress();
            
            if (vttCues.length > 0 && isPlaying) {
                const currentTime = audioPlayer.currentTime;
                const currentCue = vttCues[currentCueIndex];
                
                if (currentCue && currentTime >= currentCue.end) {
                    audioPlayer.pause();
                }
            }
        }

        async function loadLesson(lessonId) {
            if (loadingSpinner) {
                loadingSpinner.style.display = 'block';
            }
            if (playBtn) {
                playBtn.classList.add('loading');
                playBtn.disabled = true;
            }

            if (!allLessons[lessonId]) {
                console.error(`Lesson ${lessonId} not found`);
                if (lessonInfo) lessonInfo.textContent = 'Failed to load lessons data';
                return;
            }

            currentLessonId = lessonId;
            const lessonData = allLessons[lessonId];
            
            const cues = await loadVTTFromUrl(lessonData.vttUrl);
            
            if (cues.length === 0) {
                console.error(`Failed to load VTT for lesson ${lessonId}`);
                if (loadingSpinner) {
                    loadingSpinner.style.display = 'none';
                }
                return;
            }
            
            vttCues = cues;
            currentCueIndex = 0;
            
            referenceText = vttCues[0].text;
            updateNavigationButtons();
            
            if (audioPlayer) {
                audioPlayer.src = lessonData.audioUrl;
                console.log(`[DEBUG] Attempting to load audio: ${lessonData.audioUrl.substring(lessonData.audioUrl.lastIndexOf('/') + 1)}. Current Network State: ${audioPlayer.networkState}.`);
                
                audioPlayer.addEventListener('loadedmetadata', () => {
                    console.log(`[DEBUG] Metadata loaded. Duration: ${audioPlayer.duration.toFixed(2)}s. Network State: ${audioPlayer.networkState}.`);
                    if (playBtn) {
                        playBtn.classList.remove('loading', 'playing');
                        playBtn.disabled = false;
                    }
                    audioPlayer.playbackRate = currentSpeed;
                    updateProgress();
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                }, { once: true });
                
                audioPlayer.addEventListener('error', (e) => {
                    const error = e.target.error;
                    console.error('Audio Loading Error in Listener:', {
                        networkState: audioPlayer.networkState,
                        code: error ? error.code : 'N/A',
                        message: error ? error.message : 'Unknown Error Object',
                        event: e
                    });
                    if (playBtn) {
                        playBtn.classList.remove('loading');
                        playBtn.disabled = true;
                        playBtn.style.opacity = '0.5';
                    }
                    if (loadingSpinner) {
                        loadingSpinner.style.display = 'none';
                    }
                    alert('Error loading audio. Please check your internet connection or try refreshing the page.');
                }, { once: true });
            }
            
            if (referenceTextDiv) referenceTextDiv.textContent = referenceText;
            if (userInput) userInput.value = '';
            if (liveFeedback) liveFeedback.innerHTML = 'Live Feedback';
            if (statsSection) statsSection.style.display = 'none';
            
            sentenceStartTime = null;
            totalSessionTime = 0;
            hasStartedTyping = false;
            sessionResults = [];
            
            setTimeout(sendHeightToParent, 500);
        }

        function compareTexts(reference, userText) {
            userText = convertGermanChars(userText);
            
            const ignoreCase = ignoreCaseActive;
            const ignorePunctuation = true;
            
            let refNormalized = reference;
            let userNormalized = userText;
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            const result = [];
            let correct = 0;
            let wrongPosition = 0;
            let wrong = 0;
            let extra = 0;
            let missing = 0;
            
            for (let i = 0; i < alignment.length; i++) {
                const item = alignment[i];
                
                if (i > 0) {
                    result.push({ char: ' ', status: 'word-boundary' });
                }
                
                if (item.type === 'match') {
                    for (let char of item.userWord) {
                        result.push({ char, status: 'correct' });
                        correct++;
                    }
                } else if (item.type === 'substitute') {
                    const ref = item.refWord;
                    const user = item.userWord;

                    let missingPrefix = 0;
                    let missingSuffix = 0;

                    for (let idx = 1; idx <= ref.length; idx++) {
                        if (ref.slice(-idx) === user) {
                            missingPrefix = ref.length - idx;
                            break;
                        }
                    }
                    if (missingPrefix === 0) {
                        for (let idx = 1; idx <= ref.length; idx++) {
                            if (ref.slice(0, idx) === user) {
                                missingSuffix = ref.length - idx;
                                break;
                            }
                        }
                    }

                    if (missingPrefix > 0) {
                        for (let k = 0; k < missingPrefix; k++) {
                            if (k > 0) result.push({ char: ' ', status: 'char-space' });
                            result.push({ char: '_', status: 'missing' });
                            missing++;
                        }
                    }

                    for (let c = 0; c < user.length; c++) {
                        result.push({ char: user[c], status: 'wrong' });
                        wrong++;
                    }

                    if (missingSuffix > 0) {
                        for (let k = 0; k < missingSuffix; k++) {
                            result.push({ char: ' ', status: 'char-space' });
                            result.push({ char: '_', status: 'missing' });
                            missing++;
                        }
                    }

                } else if (item.type === 'insert') {
                    for (let char of item.userWord) {
                        result.push({ char, status: 'extra' });
                        extra++;
                    }
                } else if (item.type === 'delete') {
                    const wordLength = item.refWord.length;
                    
                    for (let k = 0; k < wordLength; k++) {
                        if (k > 0) {
                            result.push({ char: ' ', status: 'char-space' });
                        }
                        result.push({ char: '_', status: 'missing' });
                        missing++;
                    }
                }
            }
            
            return {
                chars: result,
                stats: { 
                    correct, 
                    wrongPosition, 
                    wrong, 
                    extra,
                    missing,
                    total: refNormalized.replace(/\s/g, '').length 
                }
            };
        }

        function alignSequencesWithGaps(refWords, userWords) {
            const N = refWords.length, M = userWords.length;
            const dp = Array.from({ length: N + 1 }, () => Array(M + 1).fill(0));

            const COST = { MATCH: 0, SUB: 3, INS: 2, DEL: 2 };

            for (let i = 0; i <= N; i++) dp[i][0] = i * COST.DEL;
            for (let j = 0; j <= M; j++) dp[0][j] = j * COST.INS;

            for (let i = 1; i <= N; i++) {
                for (let j = 1; j <= M; j++) {
                    const matchCost = dp[i - 1][j - 1] +
                        (refWords[i - 1] === userWords[j - 1] ? COST.MATCH : COST.SUB);
                    const delCost = dp[i - 1][j] + COST.DEL;
                    const insCost = dp[i][j - 1] + COST.INS;

                    dp[i][j] = Math.min(matchCost, delCost, insCost);
                }
            }

            let i = N, j = M, alignment = [];
            while (i > 0 || j > 0) {
                const current = dp[i][j];

                if (i > 0 && j > 0 &&
                    current === dp[i - 1][j - 1] +
                               (refWords[i - 1] === userWords[j - 1] ? COST.MATCH : COST.SUB)) {
                    alignment.unshift({
                        type: refWords[i - 1] === userWords[j - 1] ? 'match' : 'substitute',
                        refWord: refWords[i - 1],
                        userWord: userWords[j - 1]
                    });
                    i--; j--;
                    continue;
                }

                if (i > 0 && current === dp[i - 1][j] + COST.DEL) {
                    alignment.unshift({ type: 'delete', refWord: refWords[i - 1], userWord: null });
                    i--;
                    continue;
                }

                alignment.unshift({ type: 'insert', refWord: null, userWord: userWords[j - 1] });
                j--;
            }

            return alignment;
        }

        function updateLiveFeedback() {
            if (!userInput || !liveFeedback) return;
            
            const userText = userInput.value;
            
            if (userText.trim() === '') {
                liveFeedback.innerHTML = 'Live Feedback';
                return;
            }
            
            const comparison = compareTexts(referenceText, userText);
            
            let feedbackHTML = '';
            
            comparison.chars.forEach(item => {
                let char = item.char;
                
                if (char === ' ') {
                    if (item.status === 'word-boundary') {
                        char = '&nbsp;&nbsp;&nbsp;';
                    } else if (item.status === 'char-space') {
                        char = '&nbsp;';
                    } else {
                        char = '&nbsp;';
                    }
                } else if (char === '\n') {
                    char = '<br>';
                }
                
                feedbackHTML += `<span class="char-${item.status}">${char}</span>`;
            });
            
            liveFeedback.innerHTML = feedbackHTML;
        }

        function updateProgress() {
            if (!audioPlayer || !timeDisplay || !progressBar) return;
            
            const currentTime = audioPlayer.currentTime;
            const duration = audioPlayer.duration;
            
            if (duration) {
                const progress = (currentTime / duration) * 100;
                progressBar.style.width = progress + '%';
                
                const formatTime = (time) => {
                    const minutes = Math.floor(time / 60);
                    const seconds = Math.floor(time % 60);
                    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                };
                
                timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
            }
        }

        function calculateWordStats(comparison) {
            const ignoreCase = ignoreCaseActive;
            const ignorePunctuation = true;
            
            let refNormalized = referenceText;
            let userNormalized = userInput.value;
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            let correctWords = 0;
            let wrongWords = 0;
            let totalWords = refWords.length;
            
            alignment.forEach(item => {
                if (item.type === 'match') {
                    correctWords++;
                } else if (item.type === 'substitute' || item.type === 'delete') {
                    wrongWords++;
                }
            });
            
            return {
                correctWords,
                wrongWords,
                totalWords
            };
        }

        function showFinalResult() {
            if (!userInput) return;
            
            if (userInput.value.trim() && sessionResults.length === currentCueIndex) {
                let sentenceTime = 0;
                if (hasStartedTyping && sentenceStartTime) {
                    sentenceTime = (Date.now() - sentenceStartTime) / 1000;
                    totalSessionTime += sentenceTime;
                }

                const userText = userInput.value;
                const comparison = compareTexts(referenceText, userText);
                const wordStats = calculateWordStats(comparison);
                
                sessionResults.push({
                    sentenceIndex: currentCueIndex,
                    reference: referenceText,
                    userInput: userText,
                    stats: wordStats,
                    time: sentenceTime,
                    comparison: comparison
                });
            }
            
            let totalCorrectWords = 0;
            let totalWrongWords = 0;
            let totalWords = 0;
            
            sessionResults.forEach(result => {
                totalCorrectWords += result.stats.correctWords;
                totalWrongWords += result.stats.wrongWords;
                totalWords += result.stats.totalWords;
            });
            
            const accuracy = totalWords > 0 ? Math.round((totalCorrectWords / totalWords) * 100) : 0;
            
            if (accuracyPercent) accuracyPercent.textContent = accuracy + '%';
            if (correctWords) correctWords.textContent = totalCorrectWords;
            if (wrongWords) wrongWords.textContent = totalWrongWords;

            const timeElement = document.getElementById('timeTaken');
            if (timeElement) {
                timeElement.textContent = formatTime(totalSessionTime);
            }
            
            if (statsSection) statsSection.style.display = 'grid';
            
            const exportControls = document.getElementById('exportControls');
            if (exportControls) exportControls.style.display = 'block';
            
            showDetailedResults();
                        
            setTimeout(sendHeightToParent, 100);
        }

        function exportCSV() {
            if (sessionResults.length === 0) return;
            
            let totalCorrectWords = 0;
            let totalWrongWords = 0;
            let totalWords = 0;
            
            sessionResults.forEach(result => {
                totalCorrectWords += result.stats.correctWords;
                totalWrongWords += result.stats.wrongWords;
                totalWords += result.stats.totalWords;
            });
            
            const accuracy = totalWords > 0 ? Math.round((totalCorrectWords / totalWords) * 100) : 0;
            
            const lessonId = currentLessonId || 'Unknown';
            
            let csvContent = 'Lesson,Accuracy,Correct Words,Wrong Words,Total Words,Time Taken\n';
            csvContent += `${lessonId},${accuracy},${totalCorrectWords},${totalWrongWords},${totalWords},${formatTime(totalSessionTime)}`;
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            
            link.download = `${lessonId}-results.csv`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function showDetailedResults() {
            const sentenceResultsDiv = document.getElementById('sentenceResults');
            const sentencesContainer = document.getElementById('sentencesContainer');
            
            if (!sentenceResultsDiv || !sentencesContainer) return;
            
            sentencesContainer.innerHTML = '';
            
            sessionResults.forEach((result, index) => {
                const sentenceDiv = document.createElement('div');
                sentenceDiv.className = 'sentence-result';
                sentenceDiv.innerHTML = generateResultHTML(result);
                
                sentencesContainer.appendChild(sentenceDiv);
            });
            
            addTooltipListeners();
            
            sentenceResultsDiv.style.display = 'block';
        }

        function generateResultHTML(result) {
            const ignoreCase = ignoreCaseActive;
            const ignorePunctuation = true;
            
            let refNormalized = result.reference;
            let userNormalized = convertGermanChars(result.userInput);
            
            if (ignorePunctuation) {
                refNormalized = refNormalized.replace(/[.,!?;:""''()]/g, '');
                userNormalized = userNormalized.replace(/[.,!?;:""''()]/g, '');
            }
            
            if (ignoreCase) {
                refNormalized = refNormalized.toLowerCase();
                userNormalized = userNormalized.toLowerCase();
            }
            
            userNormalized = userNormalized.replace(/\s+/g, ' ').trim();
            
            const refWords = refNormalized.split(/\s+/).filter(w => w.length > 0);
            const userWords = userNormalized.split(/\s+/).filter(w => w.length > 0);
            
            const alignment = alignSequencesWithGaps(refWords, userWords);
            
            let html = '';
            
            alignment.forEach((item, index) => {
                if (index > 0) html += ' ';
                
                if (item.type === 'match') {
                    html += `<span class="result-word-correct">${item.userWord}</span>`;
                } else if (item.type === 'substitute') {
                    html += `<span class="result-word-wrong" data-correct="${item.refWord}">${item.userWord}</span>`;
                } else if (item.type === 'insert') {
                    html += `<span class="result-word-extra">${item.userWord}</span>`;
                } else if (item.type === 'delete') {
                    const underscoreLength = Math.max(item.refWord.length, 3);
                    const underscore = '_'.repeat(underscoreLength);
                    html += `<span class="result-word-missing" data-missing="${item.refWord}">${underscore}</span>`;
                }
            });
            
            return html;
        }

        function addTooltipListeners() {
            const wrongWords = document.querySelectorAll('.result-word-wrong');
            const missingWords = document.querySelectorAll('.result-word-missing');
            
            wrongWords.forEach(word => {
                word.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showTooltip(this, this.getAttribute('data-correct'));
                });
            });

            missingWords.forEach(word => {
                word.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showTooltip(this, this.getAttribute('data-missing'));
                });
            });
        }

        function showTooltip(element, text) {
            document.querySelectorAll('.word-tooltip').forEach(tooltip => tooltip.remove());
            
            const tooltip = document.createElement('div');
            tooltip.className = 'word-tooltip';
            tooltip.textContent = text;
            
            element.appendChild(tooltip);
            
            setTimeout(() => {
                const tooltipRect = tooltip.getBoundingClientRect();
                const containerRect = document.querySelector('.sentences-container').getBoundingClientRect();
                
                if (tooltipRect.left < containerRect.left) {
                    tooltip.classList.add('adjust-left');
                }
                else if (tooltipRect.right > containerRect.right) {
                    tooltip.classList.add('adjust-right');
                }
                
                tooltip.classList.add('show');
            }, 10);
            
            document.addEventListener('click', function hideTooltip() {
                tooltip.remove();
                document.removeEventListener('click', hideTooltip);
            });
        }
        
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // SMOOTH AUTO-RESIZE HINT SYSTEM - works with ResizeObserver
        function showHint() {
            if (!referenceText) return;
            
            const hintDisplay = document.getElementById('hintDisplay');
            const hintContent = document.getElementById('hintContent');
            
            if (!hintDisplay || !hintContent) return;
            
            // Set the hint text
            hintContent.textContent = referenceText;
            
            // Show the hint display
            hintDisplay.style.display = 'block';
            
            // ResizeObserver will automatically detect the change and resize
            // No manual sendHeightToParent() needed!
            
            // Auto-hide after 8 seconds
            setTimeout(() => {
                hideHint();
            }, 8000);
        }

        function hideHint() {
            const hintDisplay = document.getElementById('hintDisplay');
            if (hintDisplay && hintDisplay.style.display !== 'none') {
                // Hide the hint
                hintDisplay.style.display = 'none';
                
                // ResizeObserver will automatically detect the change and resize
                // No manual sendHeightToParent() needed!
            }
        }

        function showAnswer() {
            if (referenceTextDiv) {
                referenceTextDiv.style.display = 'block';
                setTimeout(() => {
                    referenceTextDiv.style.display = 'none';
                    sendHeightToParent();
                }, 10000);
                sendHeightToParent();
            }
        }
    </script>
</body>
</html>
